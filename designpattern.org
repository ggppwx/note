#+ design pattern notes 


in total we have 27 tutorials 
10 min each 
learn 20 maybe 

* outline [6/13]
- [X] review
- [X] strategy
- [X] observor
- [X] factory
- [X] abstruct
- [X] singleton
- [ ] builder
- [ ] prototype
- [ ] decorator
- [ ] bridge 
- [ ] template
- [ ] iterator 
- [ ] Facade



* review oop 
** Encapsulation 
parameter vs argument 

** how to decide if a class should extend another 
+ is a 
+ has a decide if something has a field 
+ share most methods 
+ should not use inheritance just to reuse code 

** why inheritance 

** pass mechanism
+ java value passed by value 
+ object passed by reference 
+ staic 



* DONE strategy 
  CLOSED: [2016-04-21]

** basic
+ eliminate duplicate 
+ one class should not affect the ohters 
+ use one / several behaviors dynamicly 
- increased number of classes 

** use interface 
#+BEGIN_SRC java
public interface Fly{
   String fly();
}

// let the alogithm varies 
class ItFly implements Fly{ // strategy algorithm
   public String fly(){
   }
}

class CantFly implements Fly{
public String fly(){
}
}
#+END_SRC

** composition 
+ can change without side effects 
+ Animal can be a abstruct class. abstruct class can have concrete method
#+BEGIN_SRC java
public class Animal {
  public Fly flyingType;  //setter method somewhere 
  
  /* no need to assign, if we don't instanatiate this 
  public Animal(){
    flyingType = new ItFly(); // default
  } 
  */ 
  public String tryToFly(){ 
    return flyingType.fly();
  }
}

public class Dog extends Animal{
   public Dog(){
     super();
     flyingType = new ItFly();
   }
}

Animal sparky = new Dog();
sparky.tryToFly();
#+END_SRC



* DONE observor 
  CLOSED: [2016-04-26]
** when to use observer pattern 
- loose coupling
  - subject doesn't need to know anything about subscribers

- subject may send updates that don't matter to subscriber

[[file:observer.png]]

** sample 
#+BEGIN_SRC java
public interface Subject{
    public void register(Observer o);
    public void unregister(Observer o);
    public void notifyObserver();

    
    private double ibmprice;
}

public interface Observer{
    public void update(double ibmprice);
}

// subject 
public class StockGrabber implements Subject {
    public StockGrabber{
        observers = new ArrayList<Observer>();
    }
    
    public void register(Observer o) {  // add observer 
        observers.add(o);
    }

    public void notifyObserver() { // notify all observers 
       for(Observer o : observers) {
           o.update(ibmprice);
       }
    }

    public void setIbmPrice(doulbe newp) {
       this.ibmprice = newp;
       notifyObserver();
    }

}

//observer
public class StockObserver implments Observer {
    public StockObserver(Subject stockGrabber) { // pass in a subject
       stockGrabber.register(this);
    }



    private static int observerIDTracker = 0;
    private Subject stockGrabber;


    public void update(double ibmprice) {
       this.ibmprice = ibmprice;

    }

}


// use multi-thread subjects 
public class GetTheStock implments Runnable {
   private Subject stockGrabber;  // subject 

   public GetTheStock(Subject sub, int newStratTime){
      this.stockGrabber = sub;
  
   }
     
   public void run() { // updating this subject 
       for (int i = 0; i < 20 ; ++i ) {
           (StockGrabber)stockGrabber.setIBMPrice(random())  // cast to StockGrabber
       }
   }
}



public static void main() {

  StockGrabber stockgrabber = new StockGrabber(); // subject

  StockObserver o1 = new StockObserver(stockgrabber);
  StockObserver o2 = new StockObserver(stockgrabber);
  
  stockgrabber.setIbmprice(1111); //  subject change price send notification

  stockgrabber.unregister(o2); // un-register 

  // we can have multiple subjects. 
  // run multi-thread. here are multiple subjects 
  // every t
  Runnable t1 = new GetTheStock(stockgrabber, 2);
  Runnable t2 = new GetTheStock(stockgrabber, 2);
  
  new Thread(t1).start();
  new Thread(t2).start();
}
 

#+END_SRC










* DONE factory 
  CLOSED: [2016-04-30 Sat 23:18]
** DONE use cpp rewrite the code 
   CLOSED: [2016-04-30 Sat 23:18] SCHEDULED: <2016-04-30 Sat>
*** what is factory pattern
[[file:factory.jpg]]
*** when to use
- when you don't know ahead what class you need 
- when all potenial classes are in same subclass hierarchy
- centralize class selection 
- encapsulate object creation

*** example 
#+BEGIN_SRC c++

class EnemyShip{
public:
  void followHeroShip();
  void displayShip();
  void enemyShipShoot();

};

class UFO : public EnemyShip {
};

class UFOBoss : public UFO{
};

class Rocket : public EnemyShip {
};

class EnemyShipFactory {
  static EnemyShip* makeEnemyShip(std::string type) {
    if (type == "UFO") {
      return new UFO();
    }
  }

};


int main(){
   /* bad stuff
   if (userInput == "UFO") {     
   } else {
   } 
   */   
   EnemyShip* enemy = shipFactory::makeEnemyShip("UFO");

}
#+END_SRC


*** abstruct factory 
like a factory but everything is encapsulated
- create families of related objects 
- polymorphism
+ *in a nutshell, abstruct factory pattern creates different kinds of factory,
  it makes the factory abstruct*
+ *normal factory just create abstruct object*
#+BEGIN_SRC c++

class EnemyShipBuilding{  // abstruct class/ virtual class
  protected:
  virtual EnemyShip* makeEnemyShip(std:string type) = 0;

  public: 
  EnemyShip* orderShip(std::string type){
    return makeEnemyShip(type);
  }

};

class EnemyShipBuilding : public EnemyShipBuilding {
  EnemyShip* makeEnemyShip(std:string type) {
    if(type == "UFO") { // create different factory instead of object
       EnemyShipFactory *f1 = new UFOEnemyShipFactory();  // create factory
       return new UFO(f1);
    }      
  }
};

// abstruct factory 
class EnemyShipFactory{
   virtual Weapon* addGun();
};

// different factory for diffrent ship
class UFOEnemyShipFactory : public EnemyShipFactory{
  Weapon*  addGun(){
    return new SmallGun();
  }

};

class BossEnemyShipFactory : public EnemyShipFactory{
  Weapon*  addGun(){
    return new BigGun();
  }
};

// abstruct ship
class EnemyShip{ 
  // same as above 
  virtual void makeShip() = 0;
}

class UFO : public EnemyShip {
  UFO(EnemyShipFactory* f) {
    factory = f;
  }
  void makeShip(){
    weapon = f.addGun(); //use small gun
  }
};


int main(){
  EnemyShipBuilding* makeUFO = new UFOShipBuilding(); // create a builder
  EnemyShip* ship1 = makeUFO -> orderShip("UFO");
  EnemyShip* ship2 = makeUFO -> orderShip("BOSS");
}




#+END_SRC



* DONE singleton
  CLOSED: [2016-05-06 Fri 17:51]
** when 
- it's used when you want to eliminate the option of 
instantiating more than one object

#+BEGIN_SRC c++

class Singleton{
private:
static Singleton *instance = NULL;
Singleton(){} // disable public constructor
public:
static Singleton* getInstance(){
  if (instance == NULL ) {
    instance = new Singleton();
  }
  return instance;
}
}

#+END_SRC

** threaded situtation

#+BEGIN_SRC java
public static void main(){
  Runnable getTiles = new GetTheTiles();
  Runnable getTiles1 = new GetTheTiles();

  new Thread(getTiles).start();
  new Thread(getTiles1).start();
}

public class GetTheTiles implements Runnable {
  public void run(){
    Singleton newI = Singleton.getInstance();
    System.out.printlin("instance id:" + System.identityHashCode(newI)); // not consistant in threads
    newI.getTiles(7);
  }
}

public class Singleton{
  private Singleton(){}
  private static Singleton instance = null;
  public static synchronized Singleton getInstance(){ // it checks the tread and wait, only 1 thread running, 
  // this is slow 
    ...... 
  }
}

public class Singleton{
  public static Singleton getInstance(){ // not make the whole function syncronized
    // don't need to consider multi thread if the first instance is already created.
    if (instance == null) {
      // only sync when the object is created
      synchronized(Singleton.class) {
        if ( instance == null ) {
          instance = new Singleton(); // this should be atomic: no access at the same time 
        }
      }
    }

    return instance;
  }
}

#+END_SRC




* DONE builder
  CLOSED: [2016-05-10 Tue 18:09]

** what & when
- create objects made from bunch of other objects 
- hid the creation parts 
- only builder knows specs 

#+BEGIN_SRC java
// this is a pure interface
public interface RobotPlan {
  public void setRobotHead();
  public void setRobotTorso();

}
public class Robot implements RobotPlan{
  private String robotHead; // member
  private String robotTorso;
  public void setRobotHead(){ ... }
  public void setRobotTorso(){ ... }
}


// build the robot
// you need to create diff concrete builder for each type of pruduct
public interface RobotBuilder{
  public buildRobotHead();
  ...
  public getRobot();
}
public class OldRobotBuilder implements RobotBuilder{ // concrete builder
  private Robot robot;
  public OldRobotBuilder{
    robot = new Robot();
  }
  public buildRobotHead() {
    robot.setRobotHead();
  }

  public getRobot() { return robot; } //create the products. 
}


public class RobotEngineer{ //director. 
  private RobotBuilder robotbuilder;

  public RobotEngineer(RobotBuilder rb) {  robotbuilder = rb; }
  
  public void makeRobot(){ //encapsulate all creation functions
    this.robotbuilder.buildRobotHead();
    ....
  }

  public Robot getRobot() { return this.robotbuilder.getRobot(); }
}


// main 
RobotBuilder orb = new OldRobotBuilder(); // pass to interface.
RobotBuilder nrb = new NewRobotBuilder();
RobotEngineer re = new RobotEngineer(orb);

re.makeRobot(); 
Robot r = re.getRobot();  // creation of robot is invisible

#+END_SRC


* DONE prototype
- creating new objects by cloning other objects
- reduce the needs to create multi subclasses
- create cloneFactory
- paying extremely care when overriding clone() method
#+BEGIN_SRC java

public interface Animal extends Cloneable { // not implement, it brings down all methods
  public Animal makeCopy();
}

public class Sheep implements Animal {
  public Sheep() {}
  public Animal makeCopy() {
     Sheep sheepObj = null;
     try{
     sheepObj = (Sheep)super.clone(); // only calls the parent 
     }
     return sheepObj;
  }
}


public class CloneFactory {

  public Animal getClone(Animal a) {
    return a.makeCopy();
  }

}


// main 

CloneFactory animalMaker = new CloneFactory();

Sheep s = new Sheep();
Sheep cloneS = (Sheep)animalMaker.getClone(s); // call sheep makeClone
// convert interface back to class, need convertion !
#+END_SRC


* TODO decorator


* DONE adapter
#+BEGIN_SRC java
public class EnemyRobotAdapter implements EnemyAttacker{
	EnemyRobot theRobot; // an adaptee
	
	public EnemyRobotAdapter(EnemyRobot newRobot){		
		theRobot = newRobot;		
	}
	
	public void fireWeapon() {		
		theRobot.smashWithHands();		
	}

	public void driveForward() {		
		theRobot.walkForward();		
	}

	public void assignDriver(String driverName) {		
		theRobot.reactToHuman(driverName);		
	}
		
}
#+END_SRC


* TODO bridge 


* TODO template


* TODO iterator 




