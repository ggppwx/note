
#+TITLE: leetcode mind map

[[file:map_diagram.png]]
* data structre
** min stack                                                           :WARN:
   做的不好，限制条件完全没有考虑
   use a stack to track min, only pops when nums.pop() <= minlast
   python = [] is a list 

* linked list
** remove nth node from end of the list 
   use Dummy node is the key, it saves a lot of time 

** reverse linked list                                             :reviewed:
   这么简单的题目想复杂了。太不应该了
   保存足够多的temp pointers to iterate 
   dont forget conner case list = []

** merging 2 link list
   don't forget move the node: n1 = n1.next

** Palindrome Linked List
#+begin_src python
class Solution(object):
    def isPalindrome(self, head):
        """
        :type head: ListNode
        :rtype: bool
        """
        node = head
        result1 = ""
        result2 = ""
        while node:
            result1 = result1 + str(node.val)
            result2 = str(node.val) + result2
            node = node.next
        
        return result1 == result2
#+end_src

** Linked List Cycle                                                   :WARN:
   classic problem
   2 nodes start at the same postion 
#+begin_src python
class Solution(object):
    def hasCycle(self, head):
        if head == None:
            return False
        
        node1 = head # starting at the same position 
        node2 = head
        while node1 and node2 and node2.next: 
            node1 = node1.next
            # first check node2.next but it requires node2
            # so check both
            node2 = node2.next.next 
            if node1 == node2:
                return True        
        return False
#+end_src

* array 
** Plus One
   - python array appending 
   - don't forget adding 1 first 
   - don't forget inserting last carry 

** move zero 
   - python range(n) = 0, 1, 2, ... n-1
** valid sudoku                                                        :WARN:
   - 难点是How to go through each cell 
#+begin_src python
class Solution(object):
    def isValidSudoku(self, board):
        i = 0
        j = 0
        for i in range(len(board)):
            check = {}
            check2 = {}
            check3 = {}
            for j in range(len(board)):
                if board[i][j] in check:
                    return False
                elif board[i][j] != '.':
                    check[board[i][j]] = 1
                    
                if board[j][i] in check2:
                    return False
                elif board[j][i] != '.':
                    check2[board[j][i]] = 1
                
                # key is here, consider i as number not axis.
                # we have i=9 blocks starting at 
                # (0,0) (0,3) (0,6) (3, 0) ... 
                num = board[i/3 * 3 + j/3][i%3 * 3 + j%3]
                if num in check3:
                    return False
                elif num != '.':
                    check3[num] = 1
                                      
        return True                    
#+end_src

** Rotate Image                                                    :reviewed:
   - 完全不会做 ！
   - matrix就是薄弱环节
   - write down the example 
#+begin_src python
class Solution(object):
    def rotate(self, matrix):
        length = len(matrix)
        # roate 4 points a time, similar to reverse link list problem 
        # to make the problem easy: first 
        """
        tmp = m[0][0]
        m[0][0] = m[n][0]
        m[n][0] = m[n][n]
        m[n][n] = m[0][n]
        m[0][n] = tmp
        after that, considering + offset 
        after that, considering go deeper m[0][0] --> m[i][i+offset]
        (0 ---> i; n ---> n-i)
        """
        for i in range(length-1):
            offset = 0
            while i + offset < length - 1 - i:
                tmp = matrix[i][i + offset]
                matrix[i][i + offset] = matrix[length - 1 - offset-i][i]
                matrix[length - 1 - offset-i][i] = matrix[length - 1-i][length - 1 - offset-i ]
                matrix[length - 1-i][length - 1 - offset-i] = matrix[i + offset ][length - 1 -i]
                matrix[i + offset ][length - 1 -i] = tmp
                offset += 1
#+end_src


** longest common prefix                                               :WARN:
   - be ware of corner case
   - 不要咬指甲！！！ 


** count and say
   - when writing a function:
     - check signiture
     - check return 
     - check exit condition if recursive 
       - no harm to add more exit condition 
#+begin_src python
class Solution(object):
    def countAndSay(self, n):
        def cal(a):
            # 111221
            if len(a) == 0:
                return ''            
            count = 1
            pre = a[0]
            result = ''
            for c in a[1:]:
                if c == pre:
                    count += 1
                else:
                    result += str(count) + pre
                    pre = c
                    count = 1
            
            result += str(count) + pre
            return result  # forget return type 
                    
        a = [None] * (n+1)   # pythonic reserve 
        for i in range(n+1):
            # a[i] = cala[i-1]
            if i == 0:
                a[0] = ''
            if i == 1:
                a[1] = '1'
            if i > 1:
                a[i] = cal(a[i-1])
            
        return a[n]            
#+end_src

** shuffle array                                                   :reviewed:
   - Be aware of member variable, you need to reset it after calling function
   - 严重超时。
   - this is "Fisher-Yates Algorithm"
   - python pass by reference, when in doubt, deepycopy
#+begin_src python
class Solution(object):
    def __init__(self, nums):
        self._nums = nums
        self._original = list(nums) # python need to take care of deepy copy
        

    def reset(self):
        self._nums = list(self._original) # deepcody 
        return  self._nums

    def shuffle(self):
        for i in range(len(self._nums)):
            swapidx = random.randrange(i, len(self._nums))
            self._nums[i], self._nums[swapidx] = self._nums[swapidx], self._nums[i]
                
        return self._nums
#+end_src

** generate all possible combinations
#+begin_src python
def gen(nums):
    if len(nums) == 0:
        return []
    if len(nums) == 1:  # no harm to add more exit condition
        return [nums]
    
    result = []
    for num in nums:
        left = ... 
        for comb in gen(left):
             result.append([num] + comb)

    return result
#+end_src


* string 
** Reverse String                                                  :reviewed:
   python 基础不行啊
#+begin_src python
    def reverseString(self, s):
        # [begin:end:step]
        # python string is inmutable
        return s[::-1]
#+end_src

** reverse integer                                                     :WARN:
   - consider overflow 
   - max singed integer 2³¹-1
   - python power 2**31

** First Unique Character in a String                                  :WARN:
   - use straght-foward solution first !!!!
   - O(n)
#+begin_src python
class Solution(object):
    def firstUniqChar(self, s):
        map = {}
        for i, c in enumerate(s):
            if c not in map:
                map[c] = i  # save the index
            else:
                map[c] = len(s)
                
        
        min = len(s)
        for key in map:
            if map[key] < min:
                min = map[key]
        
        if min == len(s):
            return -1
        else:
            return min
#+end_src

** Valid Anagram
   - if no unicode, we could use a array whose index is char - 'a'

** Valid Palindrome                                                    :WARN:
   - python check isalnum
   - HAVING LOOP, CONSIDER EXIT ( avoid infinite loop ) 
#+begin_src python
class Solution(object):
    def isPalindrome(self, s):
        begin = 0
        end = len(s) - 1
        while begin < end:
            while not s[begin].lower().isalnum() and begin < end:
            # use while to pass invalid chars 
                begin = begin + 1
                
            while not s[end].lower().isalnum() and begin < end:
                end = end - 1            
                
            if begin < end and s[begin].lower() != s[end].lower():
                return False
            
            begin = begin + 1
            end = end - 1
            
        return True
            
        
#+end_src

** implement strStr()
   - corner case ""
   - pre-check to ingore cases not possible, this saves time

** atoi                                                                :WARN:
   - overflow: positive/negtive
   - invalid string
   - signed
   - empty 
   - white space
#+begin_src python
class Solution(object):
    def myAtoi(self, str):
        # overflow problem 
        # invalid 
        # negtive         
        if len(str) == 0:
            return 0
        str = str.strip(' ')        
        signed = 1
        if str[0] == '-':
            signed = -1
            str = str[1:]
        elif str[0] == '+':  #能用if-else就用
            str = str[1:]
            
        MAX = 2**31 - 1
        MIN = -2**31
        result = 0
        for s in str:
            if not s.isdigit():
                return signed * result
            
            d = int(s)            
            if signed == 1 and result > (MAX - d)/10:
                return MAX
            
            if signed == -1 and result > (-1 * MIN - d)/10:
                return MIN
            
            result = result * 10 + d # += --> ++ do not use it often                         
        return signed * result
#+end_src
* 2 pointers
** Remove Duplicates from Sorted Array
   good. but be aware of coner case 

** Best Time to Buy and Sell Stock II
   good. use while do for loop
#+begin_src python
class Solution(object):
    def maxProfit(self, prices):
        """
        :type prices: List[int]
        :rtype: int
        """
        profit = 0
        i = 0
        j = 0
        while i < len(prices): # use while do for loop 
            j = i + 1
            while j < len(prices) and prices[j] > prices[j-1]:
                j = j + 1
                
            profit = profit + prices[j-1] - prices[i]            
            i = j
            
        return profit
#+end_src

** Longest Substring Without Repeating Characters


** rotate array in place
   concept not clear, k steps could be larger than length
   思路对了。解题时候又忘记了.所以还是要想清楚了再写
#+begin_src python
class Solution(object):
    def rotate(self, nums, k):
        def rota(nums, i, j):            
            while i < j:
                tmp = nums[i]            
                nums[i] = nums[j]
                nums[j] = tmp
                i += 1 # python's i++
                j -= 1
        
        rota(nums, 0, len(nums)-1)  # don't forget this 
        rota(nums, 0, k%len(nums)-1)
        rota(nums, k%len(nums), len(nums)-1)
#+end_src

* sorting & searching
** Merge Sorted Array                                              :reviewed:
   没做出来
   To save space, loop from END to START
#+begin_src python
class Solution(object):
    def merge(self, nums1, m, nums2, n):
        i = m - 1
        j = n - 1
        idx = 0
        while i >=0 and j >= 0:  # loop from end to start 
            if nums1[i] > nums2[j]:
                nums1[m + n - 1 - idx] = nums1[i]
                i = i -1
            else:
                nums1[m + n - 1 - idx] = nums2[j]
                j = j -1
            idx = idx + 1
            
        while j >= 0 :  # only check nums2, because nums1 is in-place 
            nums1[m + n - 1 - idx] = nums2[j]
            j = j - 1
            idx = idx + 1        
#+end_src

** first bad version
   typical binary searching, recursive solution 不要想太多。
#+begin_src python
class Solution(object):
    def firstBadVersion(self, n):
        self.lastBad = -1  # python closure 
        def search(i, j):
            if i > j:
                return            
            mid = (i + j)/2
            if isBadVersion(mid): # left side
                # inner functin can't change IMMUTABLE variable 
                # OR use:
                # nonlocal lastBad
                self.lastBad = mid
                search(i, mid - 1)
            else:
                search(mid + 1, j)
        
        search(1, n)
        return self.lastBad
#+end_src
* trees
** max depth of binary tree
   finish in time
** valid BST
   finish in time, having some slight troube doing python

** symmtric tree                                                       :WARN:
   stuck on this problem for a while.
   思维定势了，一开始想直接递归，但发现和subtree问题根本没关系
#+begin_src python
class Solution(object):
    def isSymmetric(self, root):
        if root == None:
            return True        
        return self.traverse(root.left, root.right)
    
    def traverse(self, left, right): # how to compare the val parallelly ? recursion
        if left == None and right == None:
            return True
        
        elif left == None or right == None:
            return False
        
        if left.val != right.val:
            return False
        
        return self.traverse(left.left, right.right) and 
        self.traverse(left.right, right.left) # don't forget compare another branch    
#+end_src

** binary tree level order traverse
   check if array has index i? check the length of the array 
   python data structre 

** sorted array to BST                                             :reviewed:
   didn't come up with the solution
   recursive solution, get the mid value everytime 
   building tree is different from traverse tree, don't confuse 

* TODO dynamic programming
  - 2 approaches: recursion and bottom up
  - key: save the states  
** Climbing Stairs
#+begin_src cpp
// classic DP
// You are climbing a stair case. It takes n steps to reach to the top.
// Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?
class Solution {
public:
    int climbStairs(int n) {
        vector<int> memo(n + 1, -1);
        return choice(n, memo);
    }
    int choice(int n , vector<int> &memo) {
        // using recursion + state dynamic approach 
        if (memo[n] != -1) {
            return memo[n];
        }
        
        if ( n ==  0 ) {
            return 0;
          }
        if ( n == 1) {
            return 1;
        }
        if ( n == 2) {
            return 2;
        }
        int result = choice(n-1, memo) + choice(n-2, memo);
        memo[n] = result;
        return result;
    }    
};
#+end_src

** best time buy & sell
this time it's not ending with i, it's the profit <= i. 
need to save state lowest

#+begin_src cpp
// 降维
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        if (prices.size() == 0 ) {
            // always dealt with this corner case first 
            // 不要心存侥幸 
            return 0;
        }
        
        // think about how brute force will do 
        // DP must be better than brute force 
        int Lowest = INT_MIN;
        vector<int> profit(prices.size(), 0);        
        for (int i = 0; i < prices.size(); i++) {
            if ( i == 0 ) {
                profit[i] = 0;
                Lowest = prices[i];
            } else {
                int max = 0;
                // only need to track lowest prices
                max = prices[i] - Lowest; 

                /*
                for (int j = 0; j <= i - 1 ; j++) {
                    max = max > (prices[i] -  prices[j]) ? max : (prices[i] -  prices[j]);
                }
                */                
                profit[i] = profit[i-1] > max ? profit[i-1] : max;
                Lowest = Lowest < prices[i] ? Lowest : prices[i];              
            }            
        }
        
        return profit[prices.size() - 1];
        
    }
};
#+end_src


** max subarray 
ending with i is the key to trasfer the problem to 1 demension 
#+begin_src cpp
// Kadane algorithm
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        if (nums.size() == 0) {
            return 0;
        }
        
        vector<int> memo(nums.size(), INT_MIN);
        
        int max = INT_MIN;
        for (int i = 0; i < nums.size(); ++i) {
            int tmp = maxSumEnding(i, nums, memo) ;
            max = max > tmp ? max : tmp;
        }
        return max;
    }
    
    int maxSumEnding(int idx, const vector<int> &nums, vector<int> &memo) {
        // find the max ENDING with index i 
        // use a DP solution
        if (memo[idx] != INT_MIN) {
            return memo[idx];
        }
        
        if (idx == 0) {
            return nums[idx];
        }
        
        int tmp = maxSumEnding(idx - 1, nums, memo) + nums[idx];
        int result = nums[idx] > tmp ? nums[idx] : tmp;
        memo[idx] = result;
        return result;
    }
};
#+end_src

** house robber
得到状态方程是最重要的
#+begin_src cpp
class Solution {
public:
    int rob(vector<int>& nums) {
        vector<int> rob(nums.size(), 0); // Ending with i
        vector<int> maxR(nums.size(), 0); // max among 
        for (int i = 0 ; i < nums.size(); i++) {            
            if (i == 0) {
                rob[i] = nums[i];
                maxR[i] = nums[i];
            }
            else if (i == 1) {
                rob[i] = nums[i];
                maxR[i] =  nums[i] > nums[i-1] ? nums[i] : nums[i-1];                  
            }
            else{
                /*
                    maxR[i-2] = max ( rob[0] -> rob[i-2])
                    save the sate if you don't want to compute max again 
                */         
                rob[i] = maxR[i-2] + nums[i];
                maxR[i] =maxR[i-1] > rob[i] ? maxR[i-1] : rob[i]; // getting the correct minR

/*
or use: BETTER solution: 
                maxR[i] = max ( maxR[i-2] + nums[i] ,  maxR[i-1] )
*/
            }            
        }
        int max = 0;
        for (int i = 0; i < nums.size(); i++) {
            max = max > rob[i] ? max : rob[i];
        }
        return max;
    }
};
#+end_src
** Longest Palindromic Substring
   - For example, “aba” is a palindome, “abc” is not.
   - how to go through a matrix ? (using offset ) 
#+begin_src cpp
// this is a typical DP problem 
// still not careful enough, forgeting the exit condition
class Solution {
public:
    string longestPalindrome(string s) {
        vector<vector<bool> > P(s.size(), vector<bool>(s.size()));
        
        for (int k = 0; k < s.size(); k++){ // don't forget to exit this loop 
        for (int i = 0; i < s.size(); i++){
            if (i + k == s.size()) {
                break;
            }
            if ( k == 0) {
                P[i][i + k] = true;    
            }
            if ( k == 1) {
                P[i][i+k] = (s[i] == s[i+k]);
            }
            if ( k > 1 ){
                P[i][i+k] = P[i+1][i+k-1] && (s[i] == s[i+k]);
            }            
        }
        }
        
        int max = -1;
        string maxstring;
        for (int i = 0; i< s.size(); i ++) {
            for (int j = i; j < s.size(); j ++) {
                if (P[i][j]) {                    
                    if ( max < j - i + 1) {
                        max = j-i + 1;
                        maxstring = s.substr(i, max);
                    }
                }
            }
        }
        return maxstring;
    }
        
};

#+end_src


** Palindromic Substrings
#+begin_src cpp
// Given a string, your task is to count how many palindromic substrings 
// in this string.
class Solution {
public:
    int countSubstrings(string s) {
        vector<vector<bool>> P(s.size(), vector<bool>(s.size(), false));
        // learn how to init a vector of vector 

        for ( int k = 0; k < s.size(); k++){
        for ( int i = 0; i < s.size(); i++) {
            if (i+k == s.size()) {
                break;
            }
            
            if (k == 0 ) {
                P[i][i+k] = true;
            } else if ( k == 1) {
                P[i][i+k] = (s[i] == s[i+k]);
            } else {
                P[i][i+k] = P[i+1][i+k-1] && (s[i] == s[i+k]);
            }            
        }
        }
        int count = 0;
        for (int i = 0; i < s.size(); i++) {
            for (int j = i; j < s.size(); j++) {
                if (P[i][j]){
                    count ++ ;
                }
            }
        }
        return count;      
    }
};


#+end_src


* bit map 
** Single Number                                                   :reviewed:
   use bit opertion. 
   没做出来
#+begin_src python
class Solution(object):
    def singleNumber(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        x = 0
        for num in nums:
            x = x ^ num
        return x
#+end_src

* math
** Fizz Buzz
   - python range(start, [stop], [step])
** count primes                                                       :ERROR:
   - Sieve of Eratosthenes algorithm
   - prime number: 2, 3, 4 ...  1 is not prime 
#+begin_src python
class Solution(object):
    def countPrimes(self, n):
        if n == 0:
            return 0        
        if n == 1:
            return 0        
        if n == 2:
            return 0        
        if n == 3:
            return 1        
        state = [False] * (n)
        state[1] = False        
        for k in range(2, int(n**(0.5))+1):
            if not state[k]: 
                #i = k
                #j = k * i
                j = k ** 2
                while j < n:
                    state[j] = True
                    #i += 1
                    #j = k * i
                    j += k                    
        res = 0            
        for k in range(2, n):
            if not state[k]:
                res += 1
            
        return res        
#+end_src

