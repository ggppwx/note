
#+TITLE: leetcode mind map

* 解题报告模版
  - 思路
  - 代码
  - 总结
    - follow up
    - 时间空间复杂度



[[file:map_diagram.png]]
* data structre
** min stack                                                           :WARN:
*** summary
    - 做的不好，限制条件完全没有考虑
      use a stack to track min, only pops when nums.pop() <= minlast
      python = [] is a list 
    - access time: O(1)

** valid parathesis
*** thoughts 
    intuition is to use a stack 
*** summary
   - 不要背题目！！！! ! ! 背思路
   - python[-1] need to check index
     - a = '' if not list else list[-1]
   - O(n)

* linked list
** easy
*** remove nth node from end of the list 
**** thoughts
     2 pointers 
**** summary
     use Dummy node is the key, it saves a lot of time 

*** reverse linked list                                            :reviewed:
**** thoughts 
     the hard part is to reverse it in place
     how to move forward the node ? save next node first 
**** code
#+begin_src python
class Solution(object):
    def reverseList(self, head):
        pre_node = None
        node = head
        while node:
            next_node = node.next    
            node.next = pre_node             
            pre_node = node
            node = next_node
        
        return pre_node
#+end_src
**** summary
    这么简单的题目想复杂了。太不应该了
    保存足够多的temp pointers to iterate 
    dont forget conner case list = []
*** merging 2 link list
**** summary
     don't forget move the node: n1 = n1.next

*** Palindrome Linked List
**** thoughts
**** code
 #+begin_src python
 class Solution(object):
     def isPalindrome(self, head):
         """
         :type head: ListNode
         :rtype: bool
         """
         node = head
         result1 = ""
         result2 = ""
         while node:
             result1 = result1 + str(node.val)
             result2 = str(node.val) + result2
             node = node.next
        
         return result1 == result2
 #+end_src

*** Linked List Cycle                                                  :WARN:
**** thoughts
    classic problem
    2 nodes start at the same postion 
**** code
 #+begin_src python
 class Solution(object):
     def hasCycle(self, head):
         if head == None:
             return False
        
         node1 = head # starting at the same position 
         node2 = head
         while node1 and node2 and node2.next: 
             node1 = node1.next
             # first check node2.next but it requires node2
             # so check both
             node2 = node2.next.next 
             if node1 == node2:
                 return True        
         return False
 #+end_src

*** intersection linked list
**** thoughts
    - instinct is to use difference
    - find diff, then make the compensatory move
    - get the diff of len(listA) and len(listB)


** medium
*** add two numbers 
**** Thoughts
     how to create a linked list ?
     - create node
     - link next 
     so, this basically it means you need to save the previous node 
     so, thinking of dummy node 
**** code
     #+begin_src python
class Solution(object):
    def addTwoNumbers(self, l1, l2):
        l = l1
        r = l2
        carry = 0
        dummy = ListNode(-1)
        dummy.next = None # trick 1 
        node = dummy
        
        while l or r: # trick 2 
            left = l.val if l else 0 # need to check if l/r is at the end 
            right = r.val if r else 0
            tmp = left + right + carry 
            new_val = tmp % 10
            carry = tmp / 10  
            node.next = ListNode(new_val)            
            node = node.next
            l = l.next if l else None  # DON'T forget check this !! at last 
            r = r.next if r else None
            
        if carry:    # trick 3, don't forget carry 
            node.next = ListNode(carry)
        
        return dummy.next        
     #+end_src
**** summary
     use dummy node is good approach 


*** odd even linked list
**** thoughts 
     so just like reverse linked list, you need to save node.next.next to forward
    - 2 pointers
    - dummy pointer
    - check None (conner cases )
    - check next, next.next. just make sure no nullptr  exception 
**** summary
     use denfensive programming, check node, node.next, node.next.next



* array 
** easy
*** Plus One
    - python array appending 
    - don't forget adding 1 first 
    - don't forget inserting last carry 

*** move zero 
    - python range(n) = 0, 1, 2, ... n-1
*** valid sudoku                                                       :WARN:
    - 难点是How to go through each cell 
 #+begin_src python
 class Solution(object):
     def isValidSudoku(self, board):
         i = 0
         j = 0
         for i in range(len(board)):
             check = {}
             check2 = {}
             check3 = {}
             for j in range(len(board)):
                 if board[i][j] in check:
                     return False
                 elif board[i][j] != '.':
                     check[board[i][j]] = 1
                    
                 if board[j][i] in check2:
                     return False
                 elif board[j][i] != '.':
                     check2[board[j][i]] = 1
                
                 # key is here, consider i as number not axis.
                 # we have i=9 blocks starting at 
                 # (0,0) (0,3) (0,6) (3, 0) ... 
                 num = board[i/3 * 3 + j/3][i%3 * 3 + j%3]
                 if num in check3:
                     return False
                 elif num != '.':
                     check3[num] = 1
                                      
         return True                    
 #+end_src

*** Rotate Image                                                   :reviewed:
    - 完全不会做 ！
    - matrix就是薄弱环节
    - write down the example 
 #+begin_src python
 class Solution(object):
     def rotate(self, matrix):
         length = len(matrix)
         # roate 4 points a time, similar to reverse link list problem 
         # to make the problem easy: first 
         """
         tmp = m[0][0]
         m[0][0] = m[n][0]
         m[n][0] = m[n][n]
         m[n][n] = m[0][n]
         m[0][n] = tmp
         after that, considering + offset 
         after that, considering go deeper m[0][0] --> m[i][i+offset]
         (0 ---> i; n ---> n-i)
         """
         for i in range(length-1):
             offset = 0
             while i + offset < length - 1 - i:
                 tmp = matrix[i][i + offset]
                 matrix[i][i + offset] = matrix[length - 1 - offset-i][i]
                 matrix[length - 1 - offset-i][i] = matrix[length - 1-i][length - 1 - offset-i ]
                 matrix[length - 1-i][length - 1 - offset-i] = matrix[i + offset ][length - 1 -i]
                 matrix[i + offset ][length - 1 -i] = tmp
                 offset += 1
 #+end_src


*** longest common prefix                                              :WARN:
    - be ware of corner case
    - 不要咬指甲！！！ 


*** count and say
    - when writing a function:
      - check signiture
      - check return 
      - check exit condition if recursive 
        - no harm to add more exit condition 
 #+begin_src python
 class Solution(object):
     def countAndSay(self, n):
         def cal(a):
             # 111221
             if len(a) == 0:
                 return ''            
             count = 1
             pre = a[0]
             result = ''
             for c in a[1:]:
                 if c == pre:
                     count += 1
                 else:
                     result += str(count) + pre
                     pre = c
                     count = 1
            
             result += str(count) + pre
             return result  # forget return type 
                    
         a = [None] * (n+1)   # pythonic reserve 
         for i in range(n+1):
             # a[i] = cala[i-1]
             if i == 0:
                 a[0] = ''
             if i == 1:
                 a[1] = '1'
             if i > 1:
                 a[i] = cal(a[i-1])
            
         return a[n]            
 #+end_src

*** shuffle array                                                  :reviewed:
    - Be aware of member variable, you need to reset it after calling function
    - 严重超时。
    - this is "Fisher-Yates Algorithm"
    - python pass by reference, when in doubt, deepycopy
 #+begin_src python
 class Solution(object):
     def __init__(self, nums):
         self._nums = nums
         self._original = list(nums) # python need to take care of deepy copy
        

     def reset(self):
         self._nums = list(self._original) # deepcody 
         return  self._nums

     def shuffle(self):
         for i in range(len(self._nums)):
             swapidx = random.randrange(i, len(self._nums))
             self._nums[i], self._nums[swapidx] = self._nums[swapidx], self._nums[i]
                
         return self._nums
 #+end_src

*** generate all possible combinations
 #+begin_src python
 def gen(nums):
     if len(nums) == 0:
         return []
     if len(nums) == 1:  # no harm to add more exit condition
         return [nums]
    
     result = []
     for num in nums:
         left = ... 
         for comb in gen(left):
              result.append([num] + comb)

     return result
 #+end_src




** medium
*** Group Anagrams
    - better solution ?

*** Longest Substring Without Repeating Characters                     :WARN:
    - python while/for, do not forget i += 1
#+begin_src python
class Solution(object):
    def lengthOfLongestSubstring(self, s):
        startpos = 0
        lsubl = 0
        
        while startpos < len(s):
            used = {}
            subl = 0
            prev_idx = len(s)
            c_i = startpos
            while c_i < len(s):
                c = s[c_i]
                if c not in used:
                    subl += 1
                    used[c] = c_i
                else: 
                    prev_idx = used[c]
                    break
                c_i += 1    # DONT FORGET THIS
                    
            lsubl = subl if subl > lsubl else lsubl
            startpos = prev_idx + 1 
        
        return lsubl
#+end_src


*** Increasing Triplet Subsequence
    - Be careful, always use explcit MAX
    - 不要图省事，用一个大数字，数字一般不够大的 ！！
#+begin_src python
class Solution:
    def increasingTriplet(self, nums):
        INT_MAX = 2 ** 32
        min1 = INT_MAX
        min2 = INT_MAX
        min3 = INT_MAX
        for num in nums:
            if num <= min1:
                min1 = num
            elif num <= min2:
                min2 = num
            elif num <= min3:
                min3 = num
        
        return min1 != INT_MAX and min2 != INT_MAX and min3 != INT_MAX
#+end_src

* string 
** Reverse String                                                  :reviewed:
   python 基础不行啊
#+begin_src python
    def reverseString(self, s):
        # [begin:end:step]
        # python string is inmutable
        return s[::-1]
#+end_src

** reverse integer                                                     :WARN:
   - consider overflow 
   - max singed integer 2³¹-1
   - python power 2**31

** First Unique Character in a String                                  :WARN:
   - use straght-foward solution first !!!!
   - O(n)
#+begin_src python
class Solution(object):
    def firstUniqChar(self, s):
        map = {}
        for i, c in enumerate(s):
            if c not in map:
                map[c] = i  # save the index
            else:
                map[c] = len(s)
                
        
        min = len(s)
        for key in map:
            if map[key] < min:
                min = map[key]
        
        if min == len(s):
            return -1
        else:
            return min
#+end_src

** Valid Anagram
   - if no unicode, we could use a array whose index is char - 'a'

** Valid Palindrome                                                    :WARN:
   - python check isalnum
   - HAVING LOOP, CONSIDER EXIT ( avoid infinite loop ) 
#+begin_src python
class Solution(object):
    def isPalindrome(self, s):
        begin = 0
        end = len(s) - 1
        while begin < end:
            while not s[begin].lower().isalnum() and begin < end:
            # use while to pass invalid chars 
                begin = begin + 1
                
            while not s[end].lower().isalnum() and begin < end:
                end = end - 1            
                
            if begin < end and s[begin].lower() != s[end].lower():
                return False
            
            begin = begin + 1
            end = end - 1
            
        return True
            
        
#+end_src

** implement strStr()
   - corner case ""
   - pre-check to ingore cases not possible, this saves time

** atoi                                                                :WARN:
   - overflow: positive/negtive
   - invalid string
   - signed
   - empty 
   - white space
#+begin_src python
class Solution(object):
    def myAtoi(self, str):
        # overflow problem 
        # invalid 
        # negtive         
        if len(str) == 0:
            return 0
        str = str.strip(' ')        
        signed = 1
        if str[0] == '-':
            signed = -1
            str = str[1:]
        elif str[0] == '+':  #能用if-else就用
            str = str[1:]
            
        MAX = 2**31 - 1
        MIN = -2**31
        result = 0
        for s in str:
            if not s.isdigit():
                return signed * result
            
            d = int(s)            
            if signed == 1 and result > (MAX - d)/10:
                return MAX
            
            if signed == -1 and result > (-1 * MIN - d)/10:
                return MIN
            
            result = result * 10 + d # += --> ++ do not use it often                         
        return signed * result
#+end_src
* 2 pointers
** easy
*** Remove Duplicates from Sorted Array
    good. but be aware of coner case 

*** Best Time to Buy and Sell Stock II
    good. use while do for loop
 #+begin_src python
 class Solution(object):
     def maxProfit(self, prices):
         """
         :type prices: List[int]
         :rtype: int
         """
         profit = 0
         i = 0
         j = 0
         while i < len(prices): # use while do for loop 
             j = i + 1
             while j < len(prices) and prices[j] > prices[j-1]:
                 j = j + 1
                
             profit = profit + prices[j-1] - prices[i]            
             i = j
            
         return profit
 #+end_src

*** Longest Substring Without Repeating Characters

*** rotate array in place
    concept not clear, k steps could be larger than length
    思路对了。解题时候又忘记了.所以还是要想清楚了再写
 #+begin_src python
 class Solution(object):
     def rotate(self, nums, k):
         def rota(nums, i, j):            
             while i < j:
                 tmp = nums[i]            
                 nums[i] = nums[j]
                 nums[j] = tmp
                 i += 1 # python's i++
                 j -= 1
        
         rota(nums, 0, len(nums)-1)  # don't forget this 
         rota(nums, 0, k%len(nums)-1)
         rota(nums, k%len(nums), len(nums)-1)
 #+end_src

** medium
*** 3 sum                                                              :WARN:
    - better way to check unique 
    - remember if a then b.  if not a then exit 
    - better to check explicitly (check len())
#+begin_src python
class Solution(object):
    def threeSum(self, nums):
        def hashed(nums):
            return ':'.join(str(num) for num in nums)
                            
        if  len(nums) < 3:
            return []
        
        result = []
        nums.sort()            
        index_c = len(nums) - 1
        used = set([]) # we could use hash to check 
        used_c = set([]) # why this line, to optimize the time
        while index_c > 0:            
            num_c = nums[index_c]
            if num_c in used_c:
                index_c -= 1
                continue
            used_c.add(num_c)
            
            tmp = self.twoSum(nums[:index_c], -num_c) 
            if  tmp:   # not tmp means if tmp is empty !!! 
                for t in tmp:
                    if  t:
                        r = t + [num_c]
                        h_r = hashed(r)
                        if h_r not in used:
                            result.append(r)
                            used.add(h_r)
                        
            index_c -= 1            
        return result
    
    def twoSum(self, nums, target):
        if len(nums) < 2:
            return [] 

        start = 0
        end = len(nums) - 1
        result = []
        while start < end:
            tmp = nums[start] + nums[end]
            if tmp > target:
                end -= 1
            elif tmp < target:
                start += 1
            else:
                result.append([nums[start], nums[end]])
                end -= 1
                start += 1                    
        return result            
#+end_src
*** set matrix 0 
    - sample solution is easy. what about don't use a lot extra space ?
#+begin_src python
class Solution(object):
    def setZeroes(self, matrix):        
        m = len(matrix)
        n = len(matrix[0])
        row = [-1] * m
        column = [-1] * n
        for i in range(m):
            for j in range(n):
                if matrix[i][j] == 0:
                    row[i] = 0
                    column[j] = 0                                          
                        
        for i in range(m):
            for j in range(n):
                if row[i] == 0 or column[j] == 0:                
                    matrix[i][j] = 0
#+end_src

* sorting & searching
** easy
*** Merge Sorted Array                                             :reviewed:
    没做出来
    To save space, loop from END to START
 #+begin_src python
 class Solution(object):
     def merge(self, nums1, m, nums2, n):
         i = m - 1
         j = n - 1
         idx = 0
         while i >=0 and j >= 0:  # loop from end to start 
             if nums1[i] > nums2[j]:
                 nums1[m + n - 1 - idx] = nums1[i]
                 i = i -1
             else:
                 nums1[m + n - 1 - idx] = nums2[j]
                 j = j -1
             idx = idx + 1
            
         while j >= 0 :  # only check nums2, because nums1 is in-place 
             nums1[m + n - 1 - idx] = nums2[j]
             j = j - 1
             idx = idx + 1        
 #+end_src

*** first bad version
    typical binary searching, recursive solution 不要想太多。
 #+begin_src python
 class Solution(object):
     def firstBadVersion(self, n):
         self.lastBad = -1  # python closure 
         def search(i, j):
             if i > j:
                 return            
             mid = (i + j)/2
             if isBadVersion(mid): # left side
                 # inner functin can't change IMMUTABLE variable 
                 # OR use:
                 # nonlocal lastBad
                 self.lastBad = mid
                 search(i, mid - 1)
             else:
                 search(mid + 1, j)
        
         search(1, n)
         return self.lastBad
 #+end_src
** medium
*** sort colors                                                       :ERROR:
    - one pass solution 做不出来 ！！
#+begin_src python
class Solution(object):
    def sortColors(self, nums):
        i0 = 0
        idx = 0
        i2 = len(nums) -1
        index = 0
        while idx <= i2:
            if nums[idx] == 0: # red
                nums[idx], nums[i0] = nums[i0], nums[idx]
                i0 += 1
                idx += 1
            elif nums[idx] == 1:
                idx += 1                
            else:
                nums[i2], nums[idx] = nums[idx], nums[i2]
                i2 -= 1
#+end_src
*** top k frequent elements
    - use heap 

*** find peak number
    - binary search 
    - exit condition
    - special condition first, general later 
      - 1, 2 numbers 
#+begin_src python
class Solution(object):
    def findPeakElement(self, nums):
        def find(start, end):            
            mid = (start + end) / 2
            if mid == start:
                return mid
            
            # no need to consider mid = 0 
            # because this always right nums[-1] < any number
            if nums[mid-1] < nums[mid]:
                return find(mid, end)
            else:
                return find(start, mid)
        
        return find(0, len(nums)) # ending from len(nums)
#+end_src

*** sarch range                                                        :WARN:
    - always doing binary serach even after found the result 
#+begin_src python
class Solution(object):
    def searchRange(self, nums, target):
        self.sp = len(nums) # always use global to avoid closure scope problem
        self.ep = -1
        
        def find(begin, end, target):
            if begin > end:
                return
            mid = (begin + end)/2
            if nums[mid] < target: #right
                find(mid + 1, end, target)
            elif nums[mid] > target:
                find(begin, mid-1, target)
            else:
                self.sp = mid if mid < self.sp else self.sp
                self.ep = mid if mid > self.ep else self.ep
                
                # 这边想错了，想太简单了。how to find next mid ? keep using binary search !
                find(begin, mid-1, target)  # find next still using bianry search 
                find(mid+1, end, target)
                
        find(0, len(nums) - 1, target)
        if self.ep == -1:
            return [-1, -1]
        
        return [self.sp, self.ep]
#+end_src

*** Search in Rotated Sorted Array                                     :WARN:
#+begin_src python
class Solution(object):
    def search(self, nums, target):
        return self.find(0, len(nums)-1, nums, target)
                
    def find(self, begin, end, nums, target):
        if begin > end:
            return -1
        
        mid = (begin + end)/2
        if nums[mid] == target:
            return mid
        
        if nums[begin] < nums[end]:
            if nums[mid] < target:
                return self.find(mid+1, end, nums, target)
            elif nums[mid] > target:
                return self.find(begin, mid-1, nums, target)
            else:
                return mid
            
        else:
            if nums[mid] >= nums[begin]:  #what if 
                # pivot on right, pivot is a GAP, not an item
                if nums[mid] > target:
                    if target > nums[begin]:
                        return self.find(begin, mid-1, nums, target)
                    elif target < nums[begin]:
                        return self.find(mid+1, end, nums, target)
                    else:
                        return begin
                elif nums[mid] < target:
                    return self.find(mid+1, end, nums, target)
                else:
                    return mid
                 
            else:
                # pivot on left
                if nums[mid] > target:
                    return self.find(begin, mid-1, nums, target)
                elif nums[mid] < target:
                    if target < nums[end]:
                        return self.find(mid+1, end, nums, target)
                    elif target > nums[end]:
                        return self.find(begin, mid-1, nums, target)
                    else:
                        return end   # confused 
                else:
                    return mid
#+end_src


*** serach in 2d matrix



* trees
** easy
*** max depth of binary tree
    finish in time
*** valid BST
    finish in time, having some slight troube doing python

*** symmtric tree                                                      :WARN:
    stuck on this problem for a while.
    思维定势了，一开始想直接递归，但发现和subtree问题根本没关系
 #+begin_src python
 class Solution(object):
     def isSymmetric(self, root):
         if root == None:
             return True        
         return self.traverse(root.left, root.right)
    
     def traverse(self, left, right): # how to compare the val parallelly ? recursion
         if left == None and right == None:
             return True
        
         elif left == None or right == None:
             return False
        
         if left.val != right.val:
             return False
        
         return self.traverse(left.left, right.right) and 
         self.traverse(left.right, right.left) # don't forget compare another branch    
 #+end_src

*** binary tree level order traverse
    check if array has index i? check the length of the array 
    python data structre 

*** sorted array to BST                                            :reviewed:
    didn't come up with the solution
    recursive solution, get the mid value everytime 
    building tree is different from traverse tree, don't confuse 

** medium
*** binary tree in order traverse (iterative)                  :ERROR:review:
    - traverse a tree like a link-list node = node.left
    - antoher solution ? 
    - 复习了还是不会 ！
    - we are using stack to store parent node 
      - stack served as STATE
    - exit condition is not len(stack) == 0
    - in order is different from post-pre-order
      - in order: insert 1 node each time, use current node + stack 
      - post order: insert 2 nodes each time, use 2 stacks 
#+begin_src python
class Solution:
    def inorderTraversal(self, root):
        if root == None:
            return []
        
        result = []
        queue = []
        node = root
        while True:  # use while true condition in queue/stack problem
            if node:  
                queue.append(node)
                node = node.left
            else:
                if (len(queue) == 0):
                    return result
                top = queue.pop()
                result.append(top.val)
                node = top.right
                                            
#+end_src
*** Binary Tree Zigzag Level Order Traversal                           :WARN:
    - 想复杂了。一开始就钻牛角尖，放入queue都时候不需要reverse
    - same as the normal level order traversel, only diffence is insert/append
      when pop up 
    - 2 ways to do in order traversal: recursive/iterative
#+begin_src python
class Solution:
    def zigzagLevelOrder(self, root):
        if root == None:
            return []
        
        result = []
        queue = []
        depth = 0
        queue.append((root, 0))
        while queue:
            front, depth = queue.pop(0)
            if (len(result) == depth):
                result.append([])
            
            if depth % 2 == 0:
                result[depth].append(front.val)
            else:
                result[depth].insert(0,front.val)
                
            if front.left:
                queue.append((front.left, depth + 1))
            if front.right:
                queue.append((front.right, depth + 1))
                
        return result        
#+end_src
*** Construct Binary Tree from Preorder and Inorder Traversal          :WARN:
    - a[-n] be aware of n = 0
    - the best practice is to not using a[-n] unless n has a exact number
#+begin_src python
class Solution:
    def buildTree(self, preorder, inorder):
        if not preorder:
            return None 
        if not inorder:
            return None
       
        root_val = preorder[0]
        root = TreeNode(root_val)  #粗心了
        # find root in inorder
        root_index = inorder.index(root_val)
        left_num = root_index
        
        # use a[-n] with cautious
            
        root.left = self.buildTree(preorder[1:1+left_num], inorder[:root_index])
        root.right = self.buildTree(preorder[1+left_num:], inorder[root_index+1:])
            
        
        return root
#+end_src
*** Populating Next Right Pointers in Each Node
    - utlize the exsiting NEXT pointer
    - always need to check if pointer exists before using it 
#+begin_src python
class Solution:
    def connect(self, root):
        if not root:
            return 
        
        if not root.left or not root.right: # leaf
            return 
        
        root.left.next = root.right
        if root.next:
            root.right.next = root.next.left
        else:
            root.right.next = None
            
        self.connect(root.left)
        self.connect(root.right)                
#+end_src

*** Kth Smallest Element in a BST
    - convert the problem to an in-order traverse
**** code
#+begin_src python
class Solution:
    def kthSmallest(self, root, k):
        res = []
        stack = []
        node = root
        while True:
            if len(res) == k:
                return res[k-1]

            if node:
                stack.append(node)
                node = node.left
            else:  
                top = stack.pop()
                res.append(top.val)
                node = top.right
                
        return None
        
#+end_src


***  Serialize and Deserialize Binary Tree                            :ERROR:
    - tree traverse not good 
      - BFS, DFS
      - pre-order, in-order, post-order
#+begin_src python
class Codec:
# BFS: use a queue to achieve BFS
    def serialize(self, root):
        if not root:
            return None
        
        queue = [root]
        res = []
        while queue:
            top = queue.pop(0)
            if top == None:
                res.append(None)
            else:
                res.append(top.val)
                
            if top:
                queue.append(top.left)
                queue.append(top.right)
            
        return json.dumps(res)
        

    def deserialize(self, data):
        if not data:
            return None
        
        array = json.loads(data)        
        index = 0
        root = TreeNode(array[0])
        queue = [root]
        while queue:   #
            if index >= len(array):
                break
            
            node = queue.pop(0)
            if node:
                index += 1
                node.left = TreeNode(array[index]) if index < len(array) and array[index] != None  else None
                index += 1
                node.right = TreeNode(array[index]) if index < len(array) and array[index] != None else None
                
                queue.append(node.left)
                queue.append(node.right)
        return root
#+end_src
*** number of islands                                                 :ERROR:
    - graph dfs !!!
    - naive soution is O(n^2), which is bad. graph solution is O(n*k)
    - be careful about the input type, is it string or int ?
**** code
#+begin_src python
class Solution:
    def numIslands(self, grid):
        if not grid:
            return 0
        
        self.m = len(grid)
        self.n = len(grid[0])
        visited = [[False] * self.n for _ in range(self.m)]
        islands = []
        count = 0
        for i in range(self.m):
            for j in range(self.n):
                # when to start running dfs
                #dont forget check if is 1
                if not visited[i][j] and grid[i][j] == '1':  
                    self.dfs(i, j, grid, visited)
                    count += 1
        return count 
    
    def dfs(self, i, j, grid,visited):
        if visited[i][j]:
            return 
        
        visited[i][j] = True        
        if i + 1 < self.m and grid[i+1][j] == '1':
            self.dfs(i+1, j, grid, visited)
        
        if i > 0 and grid[i-1][j] == '1':
            self.dfs(i-1, j, grid, visited)
            
        if j + 1 < self.n and grid[i][j+1] == '1':
            self.dfs(i, j + 1, grid, visited)
            
        if j > 0 and grid[i][j-1] == '1':
            self.dfs(i, j - 1, grid, visited)
                    
#+end_src






* backtracking
** medium
*** Letter Combinations of a Phone Number 
    - using recursion to replace N nested loops

*** Generate Parentheses                                              :ERROR:
    - all combinations could be added in exit condition.
      - not always as a return 
    - () seems to be a 2 dimension problem, need to convert it to 1 dimension
      - adding (/) one by one 
    - 不要想当然，自己随便想的排列组合法肯定是错的
    - how to do this in brute force? 
      - adding )/( step by step, 
    - how to optimize brute force? only adding valid
    - recursion argeuments:
      - a starting point: could be an state, string, node etc. 
      - what is in result usually appears in the argeuments(in some form)

#+begin_src python
'''brute force generate:
(        )
((  ()   )(   ))
'''
def gen(a):
    if len(a) == 2* n:
        result.append(a) # no return recursion
        return 

    gen(a+'(')
    gen(a+')')

class Solution(object):
    def generateParenthesis(self, n):
        result = []  
        def gen(current, left, right):
            if left == n and right == n:
                result.append(current)
                return 
            
            if left < n:
                gen(current + '(', left + 1, right)
                
            if right < left:
                gen(current + ')', left, right + 1)
            
        gen('', 0, 0 )
        return result
#+end_src


*** Permutations
    - just like previous problem 
#+begin_src python
class Solution(object):
    def permute(self, nums):
        if not nums:
            return []
        
        result = []
        def gen(current, left):
            if len(current) == len(nums):
                result.append(current)
                return 
            
            for i, num in enumerate(left):
                gen(current + [num], left[:i] + left[i+1:] ) 
                
        gen([], nums)
        return result                                
#+end_src

*** Subsets                                                            :WARN:
    - how to avoid duplicate subsets ? 
#+begin_src python
class Solution(object):
    def subsets(self, nums):
        result = []
        def gen(current, left):
            result.append(current)            
            if not left:
                return                                         
            for i, num in enumerate(left):
                gen(current + [num], left[i+1:])  # !!!        
        gen([], nums)
        return result 
#+end_src

*** word search                                                        :WARN:
    - 方法对了。但是没有最终优化
    - once found the solution, need to exit immediately !!!!
    - when doing recursion, always remmber to exit. 
      - once you found the solution, just exit.
#+begin_src python
class Solution(object):
    def exist(self, board, word):
        # self.exist_flag = False
        r_num = len(board)
        c_num = len(board[0])
        #state = [[False] * c_num for i in range(r_num)]
        def traverse(index, i, j):                        
            if i < 0 or i >= r_num or j < 0 or j >= c_num:
                return False          
            
            current = word[index]
            if board[i][j] != current:
                return False
            
            board[i][j] = '#' # reuse board so that you don't need state 
            
            # okay
            #state[i][j] = True
            if index == len(word) - 1:
                #self.exist_flag = True
                return True
            
            # how come this could save time ? once found result exit imediately
            res = (traverse(index + 1, i-1, j) or
                    traverse(index + 1, i+1, j) or
                    traverse(index + 1, i, j-1) or
                    traverse(index + 1, i, j+1) )        
            #state[i][j] = False
            board[i][j] = current
            return res
        
        if len(word) > r_num * c_num:
            return False
        
        for i in range(r_num):
            for j in range(c_num):
                if board[i][j] == word[0]:   
                    if(traverse(0, i, j)):
                        return True
        return False
        #return (self.exist_flag == True)
#+end_src
* dynamic programming
  - 2 approaches: recursion and bottom up
  - key: save the states  
** easy
*** Climbing Stairs
 #+begin_src cpp
 // classic DP
 // You are climbing a stair case. It takes n steps to reach to the top.
 // Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?
 class Solution {
 public:
     int climbStairs(int n) {
         vector<int> memo(n + 1, -1);
         return choice(n, memo);
     }
     int choice(int n , vector<int> &memo) {
         // using recursion + state dynamic approach 
         if (memo[n] != -1) {
             return memo[n];
         }
        
         if ( n ==  0 ) {
             return 0;
           }
         if ( n == 1) {
             return 1;
         }
         if ( n == 2) {
             return 2;
         }
         int result = choice(n-1, memo) + choice(n-2, memo);
         memo[n] = result;
         return result;
     }    
 };
 #+end_src

*** best time buy & sell
 this time it's not ending with i, it's the profit <= i. 
 need to save state lowest

 #+begin_src cpp
 // 降维
 class Solution {
 public:
     int maxProfit(vector<int>& prices) {
         if (prices.size() == 0 ) {
             // always dealt with this corner case first 
             // 不要心存侥幸 
             return 0;
         }
        
         // think about how brute force will do 
         // DP must be better than brute force 
         int Lowest = INT_MIN;
         vector<int> profit(prices.size(), 0);        
         for (int i = 0; i < prices.size(); i++) {
             if ( i == 0 ) {
                 profit[i] = 0;
                 Lowest = prices[i];
             } else {
                 int max = 0;
                 // only need to track lowest prices
                 max = prices[i] - Lowest; 

                 /*
                 for (int j = 0; j <= i - 1 ; j++) {
                     max = max > (prices[i] -  prices[j]) ? max : (prices[i] -  prices[j]);
                 }
                 */                
                 profit[i] = profit[i-1] > max ? profit[i-1] : max;
                 Lowest = Lowest < prices[i] ? Lowest : prices[i];              
             }            
         }
        
         return profit[prices.size() - 1];
        
     }
 };
 #+end_src


*** max subarray 
 ending with i is the key to trasfer the problem to 1 demension 
 #+begin_src cpp
 // Kadane algorithm
 class Solution {
 public:
     int maxSubArray(vector<int>& nums) {
         if (nums.size() == 0) {
             return 0;
         }
        
         vector<int> memo(nums.size(), INT_MIN);
        
         int max = INT_MIN;
         for (int i = 0; i < nums.size(); ++i) {
             int tmp = maxSumEnding(i, nums, memo) ;
             max = max > tmp ? max : tmp;
         }
         return max;
     }
    
     int maxSumEnding(int idx, const vector<int> &nums, vector<int> &memo) {
         // find the max ENDING with index i 
         // use a DP solution
         if (memo[idx] != INT_MIN) {
             return memo[idx];
         }
        
         if (idx == 0) {
             return nums[idx];
         }
        
         int tmp = maxSumEnding(idx - 1, nums, memo) + nums[idx];
         int result = nums[idx] > tmp ? nums[idx] : tmp;
         memo[idx] = result;
         return result;
     }
 };
 #+end_src

*** house robber
 得到状态方程是最重要的
 #+begin_src cpp
 class Solution {
 public:
     int rob(vector<int>& nums) {
         vector<int> rob(nums.size(), 0); // Ending with i
         vector<int> maxR(nums.size(), 0); // max among 
         for (int i = 0 ; i < nums.size(); i++) {            
             if (i == 0) {
                 rob[i] = nums[i];
                 maxR[i] = nums[i];
             }
             else if (i == 1) {
                 rob[i] = nums[i];
                 maxR[i] =  nums[i] > nums[i-1] ? nums[i] : nums[i-1];                  
             }
             else{
                 /*
                     maxR[i-2] = max ( rob[0] -> rob[i-2])
                     save the sate if you don't want to compute max again 
                 */         
                 rob[i] = maxR[i-2] + nums[i];
                 maxR[i] =maxR[i-1] > rob[i] ? maxR[i-1] : rob[i]; // getting the correct minR

 /*
 or use: BETTER solution: 
                 maxR[i] = max ( maxR[i-2] + nums[i] ,  maxR[i-1] )
 */
             }            
         }
         int max = 0;
         for (int i = 0; i < nums.size(); i++) {
             max = max > rob[i] ? max : rob[i];
         }
         return max;
     }
 };
 #+end_src
*** Longest Palindromic Substring
    - For example, “aba” is a palindome, “abc” is not.
    - how to go through a matrix ? (using offset ) 
 #+begin_src cpp
 // this is a typical DP problem 
 // still not careful enough, forgeting the exit condition
 class Solution {
 public:
     string longestPalindrome(string s) {
         vector<vector<bool> > P(s.size(), vector<bool>(s.size()));
        
         for (int k = 0; k < s.size(); k++){ // don't forget to exit this loop 
         for (int i = 0; i < s.size(); i++){
             if (i + k == s.size()) {
                 break;
             }
             if ( k == 0) {
                 P[i][i + k] = true;    
             }
             if ( k == 1) {
                 P[i][i+k] = (s[i] == s[i+k]);
             }
             if ( k > 1 ){
                 P[i][i+k] = P[i+1][i+k-1] && (s[i] == s[i+k]);
             }            
         }
         }
        
         int max = -1;
         string maxstring;
         for (int i = 0; i< s.size(); i ++) {
             for (int j = i; j < s.size(); j ++) {
                 if (P[i][j]) {                    
                     if ( max < j - i + 1) {
                         max = j-i + 1;
                         maxstring = s.substr(i, max);
                     }
                 }
             }
         }
         return maxstring;
     }
        
 };

 #+end_src


*** longest palindome substring python
    - [None] * n only works for 1 d array 
    - python init 2-d array 不要想当然！！！
 #+begin_src python
 class Solution(object):
     def longestPalindrome(self, s):
         LEN = len(s)
         P = [[False] * LEN for _ in range(LEN)] #!!!!!!!!!!
            
         for offset in range(LEN):
             for i in range(LEN):
                 if i + offset >= LEN:
                     break
                
                 if offset == 0:
                     P[i][i] =True
                     continue
                    
                 if offset == 1:
                     P[i][i+1] = (s[i] == s[i+1])
                     continue
                
                 P[i][i+offset] = P[i+1][i+offset-1] and (s[i] == s[i+offset])
                
         lsub = ''
         for i in range(LEN):
             for j in range(i, LEN):
                 if P[i][j]:
                     if j-i+1 > len(lsub):
                         lsub = s[i:j+1]
                    
         return lsub
                    
 #+end_src
*** Palindromic Substrings
 #+begin_src cpp
 // Given a string, your task is to count how many palindromic substrings 
 // in this string.
 class Solution {
 public:
     int countSubstrings(string s) {
         vector<vector<bool>> P(s.size(), vector<bool>(s.size(), false));
         // learn how to init a vector of vector 

         for ( int k = 0; k < s.size(); k++){
         for ( int i = 0; i < s.size(); i++) {
             if (i+k == s.size()) {
                 break;
             }
            
             if (k == 0 ) {
                 P[i][i+k] = true;
             } else if ( k == 1) {
                 P[i][i+k] = (s[i] == s[i+k]);
             } else {
                 P[i][i+k] = P[i+1][i+k-1] && (s[i] == s[i+k]);
             }            
         }
         }
         int count = 0;
         for (int i = 0; i < s.size(); i++) {
             for (int j = i; j < s.size(); j++) {
                 if (P[i][j]){
                     count ++ ;
                 }
             }
         }
         return count;      
     }
 };


 #+end_src


** medium
***  Jump Game                                                        :ERROR:
    - thinking about time complexity before coding 
      - if O(n^2) it is usually wrong 
      - DP is linear in this case 
#+begin_src python
class Solution(object):
    def canJump(self, nums):
        if not nums:
            return False
        
        if len(nums) == 1:
            return True
        
        # when reaching i, how many steps left ?
        P = [0] * len(nums) 
        P[0] = 0
        
        for i in range(1, len(nums)):
            P[i] = max(P[i-1], nums[i-1] ) - 1
            if P[i] < 0:
                return False
            
        return True
#+end_src

*** unique path 
    - recursion is more straight forward 
    - interation needs to go through STATE table in some special sequence
#+begin_src python
class Solution:
    def uniquePaths(self, m, n):
        P = [[0] * n for _ in range(m)]
        k = 0
        while k < m and k < n:
            
            for j in range(k, n):
                if k == 0:
                    P[k][j] = 1
                else:
                    P[k][j] = P[k-1][j] + P[k][j-1]
            
            for i in range(k, m):   
                if k == 0:
                    P[i][k] = 1
                else:
                    P[i][k] = P[i-1][k] + P[i][k-1]
            
            k += 1
            
        return P[m-1][n-1]
#+end_src

*** coin                                                              :ERROR:
    - 想法是对的，不过recursion 
    - bottom up approach is the best 
    - no need to use num/coin to get the val, just do P[i] = P[i-coin] + 1 

#+begin_src python
class Solution:
    def coinChange(self, coins, amount):
        INT_MAX = 2**31
        state = [[INT_MAX] * (amount+1) for _ in range(len(coins)) ]
        
        for i in range(len(coins)):
            coin = coins[i]
            for j in range(amount+1):
                if i == 0:
                    if j % coin == 0:                        
                        state[i][j] = int(j/coin)
                else:
                    if j >= coin:
                        tmp = 1 + state[i][j-coin]
                    else:
                        tmp = INT_MAX
                    state[i][j] = min(state[i-1][j], tmp)
        
        return state[len(coins)-1][amount] if state[len(coins)-1][amount] < INT_MAX else -1        
#+end_src

*** Longest Increasing Subsequence                                     :WARN:
    - can you do it in nlogn ?
    - max operator not fast enough
#+begin_src python
class Solution:
    def lengthOfLIS(self, nums):
        if len(nums) == 0:
            return 0
        
        l_e = [-1] * len(nums)
        for i in range(len(nums)):
            if i == 0:
                l_e[0] = 1
                continue
                
            tmp = -1 
            for k in range(1, i+1):                   
                n = l_e[i-k] + 1 if nums[i] > nums[i-k] else 1
                tmp = tmp if tmp > n else n # do not use max operator 

            l_e[i] = tmp
            
        res = -1
        for i in range(len(nums)):
            res = max(res, l_e[i])
        return res
#+end_src
* bit map 
** Single Number                                                   :reviewed:
   use bit opertion. 
   没做出来
#+begin_src python
class Solution(object):
    def singleNumber(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        x = 0
        for num in nums:
            x = x ^ num
        return x
#+end_src

** reverse Bits
   - python bit opertion 
#+begin_src python
    def reverseBits(self, n):
        sum = 0
        for i in range(32):
            remainder = n & 1 # % operatror get reminder
            sum = sum << 1 
            sum = sum ^ remainder 
            n = n >> 1
        return sum   
#+end_src


* math

** easy 
*** Fizz Buzz
    - python range(start, [stop], [step])
*** count primes                                                      :ERROR:
    - Sieve of Eratosthenes algorithm
    - prime number: 2, 3, 4 ...  1 is not prime 
 #+begin_src python
 class Solution(object):
     def countPrimes(self, n):
         if n == 0:
             return 0        
         if n == 1:
             return 0        
         if n == 2:
             return 0        
         if n == 3:
             return 1        
         state = [False] * (n)
         state[1] = False        
         for k in range(2, int(n**(0.5))+1):
             if not state[k]: 
                 #i = k
                 #j = k * i
                 j = k ** 2
                 while j < n:
                     state[j] = True
                     #i += 1
                     #j = k * i
                     j += k                    
         res = 0            
         for k in range(2, n):
             if not state[k]:
                 res += 1
            
         return res        
 #+end_src
*** hamming distance
    - use xor
    - in python3 5/2 => 2.5 (not 2), so you need to convert: int(5/2)
*** roman to integer
    - reverse array a[start, stop, steps] ====> a[-1::-1)
    - unassigned in list => END 
 #+begin_src python
 class Solution(object):
     def romanToInt(self, s):
         map = {
             'I' : 1,
             'V' : 5,
             'X' : 10,
             'L' : 50,
             'C' : 100,
             'D' : 500,
             'M' : 1000            
         }
         sum = 0
         prev = 0
         for c in s[::-1]:  # this is reverse
             current = map[c]
             if current >= prev:
                 sum += current
             else:
                 sum -= current
            
             prev = current
            
         return sum 
 #+end_src

** medium
*** Factorial Trailing Zeroes
#+begin_src python
class Solution(object):
    def trailingZeroes(self, n):
        self.total = 0
        def find5(n):
            if n == 0:
                return 
            tmp = int(n/5)
            self.total += tmp
            find5(tmp)        
        find5(n)

        return self.total
#+end_src

*** power(n,x)                                                        :ERROR:
    - binary search 
    - recursion
#+begin_src python
class Solution(object):
    def myPow(self, x, n):
        """
        :type x: float
        :type n: int
        :rtype: float
        """
        def power(x, n):
            if n == 0:
                return 1
            half = power(x, n/2)
            if n % 2 == 0:
                return half * half
            return half * half * x
        
        x = x if n >= 0 else (1/x)
        return power(x, abs(n))
               
#+end_src

*** sqrt(x)                                                           :ERROR:
    - binary serach 
    - binary serach start = mid + 1/ end = mid - 1
#+begin_src python
class Solution(object):
    def mySqrt(self, x):
        start = 0
        end = x
        if x== 0:
            return 0
        if x == 1:
            return 1
        
        while start <= end:
            mid = start + (end - start) /2 
                
            if x/mid > mid:
                start = mid + 1
            elif x/mid < mid:
                end = mid - 1
            else:
                return mid
        
        return end 
#+end_src
*** Fraction to Recurring Decimal                                      :WARN:
#+begin_src python
class Solution(object):
    def fractionToDecimal(self, numerator, denominator):
        sign = 1        
        if numerator * denominator >= 0:
            sign =1
        else:
            sign = -1

        result =""
        numerator=abs(numerator)
        denominator=abs(denominator)
        integ = int(numerator/denominator)
        if sign >= 0:
            result += str(integ)
        else:
            result += '-' + str(integ)
        
        remainder = numerator % denominator
        rmap ={}
        if remainder != 0:
            result += "."        
            remainder = remainder * 10
            # decimal 
            result1 = []
            index = 0
            while remainder != 0:
                
                if remainder in rmap:
                    result1.insert(rmap[remainder], '(')
                    result1 += [')']
                    return result + ''.join(result1)
                    
                rmap[remainder] = index
                res = int(remainder / denominator)
                remainder = remainder % denominator
                result1 += [str(res)]
                remainder = remainder * 10
                index += 1   
            return result + ''.join(result1)
        return result
#+end_src
* others
** easy
*** Pascal's Triangle
    - python reserve [[]] * n
    - another approach: Binomial coefficient
     
** medium
*** sum of 2 integers                                                 :ERROR:
    - consider negative numbers 
    - 完全不会做

*** Evaluate Reverse Polish Notation                                   :WARN:
    - use python 3 !!!! int(-1/2) = 0
    - int python 2 (-1/2) = -1

*** majority number 
    - corner case len(nums) = 1
#+begin_src python
class Solution:
    def majorityElement(self, nums):
        size = len(nums)
        num_map = {}
        for num in nums:
            if num in num_map:
                num_map[num] += 1
            else:
                num_map[num] = 1

            # check the condition after insert 
            if num_map[num] > int(size/2):
                return num
            
        return None
#+end_src

*** Task Scheduler                                                    :ERROR:
#+begin_src python
class Solution:
    def leastInterval(self, tasks, n):
        """
        :type tasks: List[str]
        :type n: int
        :rtype: int
        """
        if n == 0:
            return len(tasks)
        if not tasks:
            return 0
        
        
        task_map = {}
        result = [None] * (n+1) * len(tasks)
        index = 0
        
        task_count = {}
        for task in tasks:
            if not task in task_count:
                task_count[task] = 1
            else:
                task_count[task] += 1
                            
        count = 0        
        sum = 0
        total = None
        count = 0
        maxcount = None
        for task in sorted(task_count, key=task_count.get, reverse=True):
            if count == 0:
                maxcount = task_count[task]
                total = (task_count[task]-1) * (n + 1)
            
            if count == n+1:
                break
            
            if task_count[task] == maxcount:
                total += 1
            
            sum += task_count[task]
            count += 1
                     
        
        empty = total - sum
        left = len(tasks) - sum                
        extra = left - empty if left >= empty else 0        
        return total + extra               
#+end_src





