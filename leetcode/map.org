#+TITLE: leetcode mind map
#+SETUPFILE: theme-bigblow.setup
#+OPTIONS:   num:nil
#+MACRO: color @@html:<span style="color: $1">$2</span>@@
#+HTML_HEAD: <script> var HS_STARTUP_FOLDED = true; var HS_COLLAPSIBLE_HEADERS_MAX = 3</script>
#+bind: org-export-publishing-directory "../docs"
* guide
** test1
*** test2
**** test3
     text 3
***** test4
      text 4

** leetcode on topic plan
*** DONE [[array][Array]]
    CLOSED: [2018-05-26 Sat 11:22]
*** DONE tree/BST*
    CLOSED: [2018-05-26 Sat 11:22]
*** DONE dfs/bfs
    CLOSED: [2018-05-26 Sat 11:22]
*** DONE hash table
    CLOSED: [2018-05-26 Sat 19:10]
*** DONE strinG
*** DONE linked list
    CLOSED: [2018-05-30 Wed 20:13]
*** DONE binary serach
    CLOSED: [2018-06-09 Sat 18:40]
    - how to do binary serach 
*** DONE [[graph ][graph]]
    CLOSED: [2018-06-20 Wed 22:05]
*** DONE [[backtracking]]
    CLOSED: [2018-07-02 Mon 20:57]
*** DONE trie
    CLOSED: [2018-07-02 Mon 20:57]
*** TODO two pointers
*** TODO dynamic programming
*** TODO divide and conquer
    - what is d&D
    - online video 
*** TODO math
*** TODO stack/heap/queue
*** TODO greedy
*** TODO sort
*** TODO bit manipulation
*** TODO union find
*** TODO desgin
*** TODO toplogical sort
*** TODO brinary indexed tree/segment tree
*** TODO recursion
*** TODO geometry
*** TODO reservoir sampling 
*** TODO minimax


** review guideline
*** binary search 
*** 2 pointers 
    2 pointers is usually on  sorted array/list 
*** Bfs
*** topological sorting 
*** dfs
*** combination-based dfs
*** graphic-based dfs
*** data structure 
**** stack
**** queue
**** heap
**** hash map 
**** arrray
**** interval
**** matrix 
**** binary indexed tree
**** deque 
*** union find
*** trie 
*** sweep line
*** dynamic programming 

** leetcode review
   see TODOs 

** 解题报告模版
- 思路
- 代码
- 总结
 - follow up
 - 时间空间复杂度


* binary serach
** {{{color(red, Easy)}}}
** Find Smallest Letter Greater Than Target
*** problem
Input: letters = ["c", "f", "j"]
target = "a"
Output: "c"
*** Thoughts
    - typical binary search 
*** code
    #+begin_src python
class Solution:
    def nextGreatestLetter(self, letters, target):
        l = 0
        r = len(letters) - 1
        while l <= r:
            mid = int((l+r)/2)
            mid_letter = letters[mid]
            if ord(target) >= ord(mid_letter):
                l = mid + 1
            else:
                r = mid - 1
                
        if r + 1 >= len(letters):
            return letters[0]
        
        return letters[r + 1]
    #+end_src
*** summary
    - use while l <= r approach
    - writing down corner cases/ bound cases is VERY helpful

** {{{color(red, Medium)}}}
**  Find Right Interval
*** problem
Given a set of intervals, for each of the interval i, check if there exists an interval j whose start point is bigger than or equal to the end point of the interval i, which can be called that j is on the "right" of i.
Example 3:
Input: [ [1,4], [2,3], [3,4] ]
Output: [-1, 2, -1]
*** Thoughts
    - brute force: O(n^2), the solution must be better than it 
    - thinking about sort & binary search.
      - how to maintain the original order of the array? save actual info (index) in intervals
      - after sorting, use binary serch to get the interval meets requirement 
*** code
    #+begin_src python
class Solution:
    def findRightInterval(self, intervals):
        def findindex(inter, ins):
            target = inter[1]
            l = 0
            r = len(ins) - 1
            while l <= r:
                mid = int((l+r)/2)
                mid_val = ins[mid][0]
                if target > mid_val:
                    l = mid + 1
                elif target < mid_val:
                    r = mid - 1
                else:
                    return ins[mid][2]
                
            if r +1 >= len(ins):
                return -1 
            return ins[r + 1][2]
        
        result = [-1] * len(intervals)
        ins = []
        for index, inter in enumerate(intervals):
            ins.append((inter.start, inter.end, index))
            
        ins = sorted(ins, key = lambda v : (v[0])) # sort by start 
        for i, inter in enumerate(ins):
            # find index for inter in [i+1 : ]
            orginal_index = inter[2] 
            result[orginal_index] = findindex(inter, ins[i+1:])
            
        return result 
    #+end_src
*** summary
    - be aware of bound. 
      - in binary serach if r + 1 >= len(inputs), this means unable to find it 
    - why use r + 1 ? 
      - it needs to find the closest item, it must exceed l == r
        - thinking about extreme case first.
          - only one item ? l = r = 0, if we don't want to calculate it separately
            the while condition should be l <= r






** Find K Closest Elements
*** problem
Given a sorted array, two integers k and x, find the k closest elements to x in the array. The result should also be sorted in ascending order. If there is a tie, the smaller elements are always preferred.
Example 1:
Input: [1,2,3,4,5], k=4, x=3
Output: [1,2,3,4]
*** Thoughts
    - binary serach find the number closest to x
    - 2 pointers search starting from the closest number
*** code
    #+begin_src python
class Solution:
    def findClosestElements(self, arr, k, x):
        if k == 0 :
            return []
        
        def find(arr, x):
            l = 0
            r = len(arr) - 1
            while l <= r:
                mid = int((l + r) / 2)
                if arr[mid] < x:
                    l = mid + 1
                elif arr[mid] > x:
                    r = mid - 1
                else:
                    return mid
            # between r,  r + 1
            if r == -1:
                return r + 1
            if r == len(arr) - 1:
                return r
            
            if abs(x - arr[r]) <= abs(x-arr[r+1]):
                return r
            else:
                return r+1
                        
        pos = find(arr, x)
        l = pos-1
        r = pos+1
        count = 1
        while count < k:
            count += 1
            if l < 0 and r >= len(arr):
                break
            if l < 0:
                r += 1
                continue
            if r >= len(arr):
                l -= 1
                continue
                
            if abs(arr[l] - x) <= abs(arr[r] - x):
                l -= 1
            else:
                r += 1
                
        return arr[l+1:r]            
    #+end_src
*** summary
    - 2 pointer search starting point: should be pos -1, pos + 1
    - special case: k = 0, k= 1



** Search in Rotated Sorted Array II                                  :ERROR:
*** problem
Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.
(i.e., [0,0,1,2,2,5,6] might become [2,5,6,0,0,1,2]).
*** Thoughts
    - similar to [[Search in Rotated Sorted Array]]
    - binary serach
    - change left, right based on 1. mid_val 2. pivot 
    - how to deal when mid_val == left ? 
      - it means just no need to consider current left, l = l + 1 ( or r = r - 1)
*** code
    #+begin_src python
class Solution:
    def search(self, nums, target):
        l = 0
        r = len(nums) - 1
        while l <= r:
            mid = int( (l + r)/ 2)
            mid_val = nums[mid]
            
            if mid_val == target:
                return True
            
            if mid_val > nums[l]:
                # mid . pivot
                if nums[l] <= target and target < mid_val:
                    r = mid - 1
                else:
                    l = mid + 1
                    
            elif mid_val < nums[l]:
                # pivot . mid
                if mid_val < target and target <= nums[r]:
                    l = mid + 1
                else:
                    r = mid - 1
            else:
                l += 1
        
        return False
    #+end_src
*** summary
    - this problem is similar to rotated sorted array unique
      - the only difference is to deal with when midval = left






** H-Index II                                                         :ERROR:
*** problem
Given an array of citations sorted in ascending order (each citation is a non-negative integer) of a researcher, write a function to compute the researcher's h-index.
*** Thoughts
    - simillar to [[H-Index]]
    - use binary serach
      - h is in [0, N], if h < left bound, h needs to increase. 
    - when mid meets condition.
      - since we need to get the max h-index, new result could only on its right side 
        
*** code
    #+begin_src python
class Solution:
    def hIndex(self, citations):
        l = 0
        r = len(citations)
        result = None
        # h is l, r
        while l <= r:
            h = int( (l + r)/2 )
            left = citations[-h-1] if h < len(citations)-1 else -1000000
            right = citations[-h] if h > 0 else 1000000
            if left <= h and right >= h:
                # meet condition
                result = h
                l = h + 1
            if left > h:
                l = h + 1
            elif right < h:
                r = h - 1
                        
        return result            
    #+end_src
*** summary
    - if a problem is to find a number from n to m, we could use binary search 
    - draw pictures to help understanding the problem 
    - how to deal with mid = h ? do not exit. just save the result 
    - could use INT_MAX, INT_MIN to mimic the outbound node



* DONE 2 pointers
  CLOSED: [2018-09-22 Sat 11:26]
** {{{color(red, Easy)}}}
** Remove Duplicates from Sorted Array
   good. but be aware of coner case 


** Longest Substring Without Repeating Characters

** rotate array in place
   concept not clear, k steps could be larger than length
   思路对了。解题时候又忘记了.所以还是要想清楚了再写
#+begin_src python
class Solution(object):
    def rotate(self, nums, k):
        def rota(nums, i, j):            
            while i < j:
                tmp = nums[i]            
                nums[i] = nums[j]
                nums[j] = tmp
                i += 1 # python's i++
                j -= 1
        
        rota(nums, 0, len(nums)-1)  # don't forget this 
        rota(nums, 0, k%len(nums)-1)
        rota(nums, k%len(nums), len(nums)-1)
#+end_src

** {{{color(red, Medium)}}}

** 3 sum                                                               :WARN:
    - better way to check unique 
    - remember if a then b.  if not a then exit 
    - better to check explicitly (check len())
#+begin_src python
class Solution(object):
    def threeSum(self, nums):
        def hashed(nums):
            return ':'.join(str(num) for num in nums)
                            
        if  len(nums) < 3:
            return []
        
        result = []
        nums.sort()            
        index_c = len(nums) - 1
        used = set([]) # we could use hash to check 
        used_c = set([]) # why this line, to optimize the time
        while index_c > 0:            
            num_c = nums[index_c]
            if num_c in used_c:
                index_c -= 1
                continue
            used_c.add(num_c)
            
            tmp = self.twoSum(nums[:index_c], -num_c) 
            if  tmp:   # not tmp means if tmp is empty !!! 
                for t in tmp:
                    if  t:
                        r = t + [num_c]
                        h_r = hashed(r)
                        if h_r not in used:
                            result.append(r)
                            used.add(h_r)
                        
            index_c -= 1            
        return result
    
    def twoSum(self, nums, target):
        if len(nums) < 2:
            return [] 

        start = 0
        end = len(nums) - 1
        result = []
        while start < end:
            tmp = nums[start] + nums[end]
            if tmp > target:
                end -= 1
            elif tmp < target:
                start += 1
            else:
                result.append([nums[start], nums[end]])
                end -= 1
                start += 1                    
        return result            
#+end_src

**  4Sum
*** Thoughts
    - thinking about 2 sum, 3sum
    - could be done in recursion, nsum ---> (k-1)sum
*** code
    #+begin_src python
class Solution(object):
    def fourSum(self, nums, target):
        nums = sorted(nums)
        def sum2(nums, target):
            nums = sorted(nums)
            s = 0
            e = len(nums) - 1
            result = []
            while s < e:
                tmp = nums[s] + nums[e]
                if  tmp > target:
                    e -= 1
                elif tmp < target:
                    s += 1
                else:
                    result.append([nums[s], nums[e]]) 
                    e -= 1
                    s += 1
            return result
        
        def ksum(k, nums, target):
            if k == 2:
                return sum2(nums, target)
            
            result = []
            for i, num in enumerate(nums):
                new_target = target - num
                left = nums[i+1:] # no need to compute nums[:i]
                res = ksum(k-1, left, new_target)
                for r in res:
                    new_r = [num] + r
                    result.append(new_r)
            
            return result 
                        
        sum4 = ksum(4, nums, target)
        res_set = set([])
        result = []
        for res in sum4:          
            r1 = sorted(res)            
            key = '#'.join([str(r11) for r11 in r1])
            if key not in res_set:                
                res_set.add(key)
                result.append(r1)
                    
        return result
    #+end_src
*** summary
    - use ''.join([..]) to calculate the key 
    - when computing i .. 2sum(nums) ----> nums starts from nums[i+1:]
      - why? because it's sorted !!
    - no extra space because of 2 pointer approach


** 80. Remove Duplicates from Sorted Array II
*** problem
Given nums = [1,1,1,2,2,3],
Your function should return length = 5, with the first five elements of nums being 1, 1, 2, 2 and 3 respectively.
It doesn't matter what you leave beyond the returned length.
*** Thoughts
*** code
    #+begin_src python
class Solution(object):
    def removeDuplicates(self, nums):
        # 0, 0, 1, 1, 1, 1, 2, 3, 3
        p = 0         
        for r in range(len(nums)):
            curr = nums[r]
            if p == 0:
                nums[p] = curr
                p += 1
            elif p == 1:
                nums[p] = curr
                p += 1
                
            elif nums[p-1] != curr:
                nums[p] = curr
                p += 1
                              
            elif nums[p-1] == curr and nums[p-2] != curr:
                nums[p] = curr
                p += 1
            elif nums[p-1] == curr and nums[p-2] == curr:
                # no change
                continue                
        return p
    #+end_src
*** summary


** set matrix 0 
    - sample solution is easy. what about don't use a lot extra space ?
#+begin_src python
class Solution(object):
    def setZeroes(self, matrix):        
        m = len(matrix)
        n = len(matrix[0])
        row = [-1] * m
        column = [-1] * n
        for i in range(m):
            for j in range(n):
                if matrix[i][j] == 0:
                    row[i] = 0
                    column[j] = 0                                          
                        
        for i in range(m):
            for j in range(n):
                if row[i] == 0 or column[j] == 0:                
                    matrix[i][j] = 0
#+end_src



** 881. Boats to Save People
*** problem
The i-th person has weight people[i], and each boat can carry a maximum weight of limit.
Each boat carries at most 2 people at the same time, provided the sum of the weight of those people is at most limit.
Return the minimum number of boats to carry every given person.  (It is guaranteed each person can be carried by a boat.)
*** Thoughts
     - thinking about 2sum, use l/r 2 pointers
     - when moving l/r, also update the result 
     - corner case: if l == r
*** code
    #+begin_src python
class Solution(object):
    def numRescueBoats(self, people, limit):
        result = 0
        people = sorted(people)
        l = 0
        r = len(people) - 1
        while l <= r:
            if l == r:
                result += 1
                break
                
            if people[l] + people[r] > limit:
                result += 1
                r -= 1
            else:
                result += 1
                r -= 1
                l += 1
                
        return result 
    #+end_src
*** summary



** 567. Permutation in String
*** problem
Given two strings s1 and s2, write a function to return true if s2 contains the permutation of s1. In other words, one of the first string's permutations is the substring of the second string.
*** Thoughts
    - approach 1: brute force 
    - approach 2: sliding window 
*** code
    #+begin_src python
class Solution(object):
    def checkInclusion(self, s1, s2):
        s1_map = [0] * 26
        for s in s1:
            idx = ord(s) - ord('a')
            s1_map[idx] +=  1
                
        temp_map = list(s1_map)
        i = 0
        counter = 0
        while i + counter < len(s2):
            s = s2[i+counter]
            idx = ord(s) - ord('a')
            if temp_map[idx] > 0:
                temp_map[idx] -= 1
                counter += 1
            elif counter > 0:
                temp_map = list(s1_map)
                i = i + 1
                counter = 0 
            else:
                i = i + 1
                 
            if counter == len(s1):
                return True
        
        return False

# sliding window approach
class Solution(object):
    def checkInclusion(self, s1, s2):
        if len(s1) > len(s2):
            return False
        
        s1_map = [0] * 26
        for s in s1:
            idx = ord(s) - ord('a')
            s1_map[idx] += 1
                

        temp_map = [0] * 26
        counter = 0
        while counter < len(s1):
            s = s2[counter]
            idx = ord(s) - ord('a')
            temp_map[idx] += 1
            counter += 1
            
        len1 = len(s1)
        i = 0
        while i + len1 < len(s2):
            #print s1_map 
            #print temp_map
            if s1_map == temp_map:
                return True
            else:
                temp_map[ord(s2[i]) - ord('a')] -= 1
                temp_map[ord(s2[i+len1]) - ord('a')] +=  1
                i = i + 1
            
        
        return s1_map == temp_map
    #+end_src
*** summary
    - in some cases, sliding window may not be faster, because it's always go through len(s1)
    - time saving happens when updating the map, no need to copy the whole map 
    - be a ware of corner case: if window reaches the last 
      - let's say len(s1) == len(s2), not going into the loop at all 



* stack/heap/queue
** {{{color(red, Easy)}}}
** min stack                                                           :WARN:
*** summary
    - 做的不好，限制条件完全没有考虑
      use a stack to track min, only pops when nums.pop() <= minlast
      python = [] is a list 
    - access time: O(1)

** valid parathesis
*** thoughts 
    intuition is to use a stack 
*** summary
   - 不要背题目！！！! ! ! 背思路
   - python[-1] need to check index
     - a = '' if not list else list[-1]
   - O(n)


** 496. Next Greater Element I
*** problem
You are given two arrays (without duplicates) nums1 and nums2 where nums1’s elements are subset of nums2. Find all the next greater numbers for nums1's elements in the corresponding places of nums2.
The Next Greater Number of a number x in nums1 is the first greater number to its right in nums2. If it does not exist, output -1 for this number.
*** Thoughts
    - using stack to get the next lager number
    - using hash_map to save the relationship
*** code
    #+begin_src python
class Solution(object):
    def nextGreaterElement(self, findNums, nums):
        num_map = {}
        stack = []
        for i, num in enumerate(nums):
            while stack and num > stack[-1]:
                last = stack.pop()
                num_map[last] = num
            
            stack.append(num)
            
        return [ num_map.get(n, -1) for n in findNums]
        
    #+end_src
*** summary




** {{{color(red, Medium)}}}
** Kth Smallest Element in a Sorted Matrix                            :ERROR:
*** problem
*** Thoughts
    - kth smallest, use heap. 
      - python heapq, push/pop O(logn)
*** code
    #+begin_src python
class Solution(object):
    def kthSmallest(self, matrix, k):
        import heapq 
        INT_MAX = 2**31 -1 
        n = len(matrix)
        result = None
        min_heap = []
        for i in range(n):
            for j in range(n):
                heapq.heappush(min_heap, matrix[i][j])
        
        for i in range(k):
            result = heapq.heappop(min_heap)
        return result 
        """
        for i in range(k):
            result = matrix[0][0]    
            # swap first and last 
            matrix[0][0] = matrix[n-1-int(i/n)][int(n-1-i%n)]
            matrix[n-1-int(i/n)][n-1-i%n] = INT_MAX # max
            
            # heapfy 
            i1 = 0
            j1 = 0
            while i1 <= n-1-int(i/n) or j1 <= n-1-i%n:
                left = matrix[i1+1][j1] if i1 < n-1 else INT_MAX
                right = matrix[i1][j1+1] if j1 < n-1 else INT_MAX
                if left == INT_MAX and right == INT_MAX:
                    break
                
                i2 = -1
                j2 = -1
                if left < right:
                    i2 = i1+1
                    j2 = j1
                else:
                    i2 = i1
                    j2 = j1 + 1
                
                if matrix[i2][j2] < matrix[i1][j1]:
                    matrix[i1][j1], matrix[i2][j2] = matrix[i2][j2], matrix[i1][j1]
                    i1 = i2
                    j1 = j2
                else:
                    break
                
        return result  
        """
    #+end_src
*** summary
    - no extra space heap?
    - binary search 

** Flatten Nested List Iterator
*** problem
Given a nested list of integers, implement an iterator to flatten it.
*** Thoughts
    - iteator: i.next() ---> val[i++]   i.hasnext() ---> i+1 < len(val)
*** code
    #+begin_src python
class NestedIterator(object):

    def __init__(self, nestedList):
        """
        Initialize your data structure here.
        :type nestedList: List[NestedInteger]
        """
        self._data = list(nestedList)
        self._f_data = self.flatten(self._data)
        self._index = -1
        
    def flatten(self, data):
        # if data is list
        result = []
        if isinstance(data, list):
            for d in data:
                result += self.flatten(d)
        elif isinstance(data, NestedInteger): # note the argument type 
            if data.isInteger():
                result.append(data.getInteger())
            else:
                result = result + self.flatten(data.getList())                                
        else:
            raise Exception("not supported")
        return result 

    def next(self):
        """
        :rtype: int
        """
        self._index += 1
        result = self._f_data[self._index]
        return result 

    def hasNext(self):
        """
        :rtype: bool
        """
        return self._index < len(self._f_data)-1
        
    #+end_src
*** summary
    - instance(data, class_name) to check the type




** 856. Score of Parentheses
*** problem
Given a balanced parentheses string S, compute the score of the string based on the following rule:
() has score 1
AB has score A + B, where A and B are balanced parentheses strings.
(A) has score 2 * A, where A is a balanced parentheses string.
*** Thoughts
    - simple stack 
*** code
    #+begin_src python
class Solution(object):
    def scoreOfParentheses(self, S):
        if not S:
            return 0
        
        stack = []
        for s in S:
            if s == ')':
                val = 0
                while stack and stack[-1] != '(':
                    val += stack.pop()
                    
                # now it's '('
                stack.pop()
                if val == 0:
                    stack.append(1)
                else:
                    stack.append(val * 2)
            else:
                stack.append(s)
        
        return sum(stack)  # () () 
    #+end_src
*** summary
    - 要考虑多种情况，比如最后不是求stack[0], ()() => 1, 1


** 739. Daily Temperatures                                            :ERROR:
*** problem
Given a list of daily temperatures, produce a list that, for each day in the input, tells you how many days you would have to wait until a warmer temperature. If there is no future day for which this is possible, put 0 instead.
For example, given the list temperatures = [73, 74, 75, 71, 69, 72, 76, 73], your output should be [1, 1, 4, 2, 1, 1, 0, 0].
Note: The length of temperatures will be in the range [1, 30000]. Each temperature will be an integer in the range [30, 100].
*** Thoughts
    - naive solution O(n^2) exceeding time 
    - save the index, the gap will be differnce of index (index_a - index_b ) 
      so that you don't have to go through it again to get the gap 
*** code
    #+begin_src python
class Solution(object):
    def dailyTemperatures(self, temperatures):
        result = [0] * len(temperatures)
        stack = []
        for i in range(len(temperatures)):
            ik = len(temperatures) - 1 - i
            t = temperatures[ik]
            while stack and t >= stack[-1][0]:
                stack.pop()
            
            if stack:
                result[ik] = i - stack[-1][1]
                
            stack.append((t, i))
        
        return result 
    #+end_src
*** summary
    - python optimization:
      - reverse() costly 
      - append() time >> array assignment 
        so init the list at begining rather than append()


** 636. Exclusive Time of Functions
*** problem
Input:n = 2
logs = 
["0:start:0",
 "1:start:2",
 "1:end:5",
 "0:end:6"]
Output:[3, 4]
Explanation:
Function 0 starts at time 0, then it executes 2 units of time and reaches the end of time 1. 
Now function 0 calls function 1, function 1 starts at time 2, executes 4 units of time and end at time 5.
Function 0 is running again at time 6, and also end at the time 6, thus executes 1 unit of time. 
So function 0 totally execute 2 + 1 = 3 units of time, and function 1 totally execute 4 units of time.
*** Thoughts
    - stack approach, simmilar to matching brace 
*** code
    #+begin_src python
class Solution(object):
    def exclusiveTime(self, n, logs):
        result = [0] * n
        stack = []
        for log in logs:
            l = log.split(':')
            job = int(l[0])
            op = l[1]
            time = int(l[2])
            
            if op == 'end':
                tmp = 0
                while stack[-1][1] != 'start':
                    last  = stack.pop()
                    tmp += last[2]
                    
                period = time - stack[-1][2] + 1
                stack.pop()
                stack.append((job, 'acc', period))
                result[job] += period - tmp                
            else:            
                stack.append((job, op, time))
                
        return result 
    #+end_src
*** summary


** 503. Next Greater Element II                                        :WARN:
*** problem
Given a circular array (the next element of the last element is the first element of the array), print the Next Greater Number for every element. The Next Greater Number of a number x is the first greater number to its traversing-order next in the array, which means you could search circularly to find its next greater number. If it doesn't exist, output -1 for this number.
*** Thoughts
    - ending condition, it meets the exact same number again 
      - saving index as a flag to check if number is exact the same 
*** code
    #+begin_src python
class Solution(object):
    def nextGreaterElements(self, nums):
        """
        :type nums: List[int]
        :rtype: List[int]
        """
        result = [-1] * len(nums)
        stack = []
        for _ in range(2):
            for idx, num in enumerate(nums):
                while stack and num > stack[-1][0]:
                    last = stack.pop()
                    result[last[1]] = num
                    
                if stack and stack[-1][1] == idx:
                    return result
                    
                stack.append((num, idx))
        return result 
                    
    #+end_src
*** summary
    - better solution ? 


** 331. Verify Preorder Serialization of a Binary Tree
*** problem
One way to serialize a binary tree is to use pre-order traversal. When we encounter a non-null node, we record the node's value. If it is a null node, we record using a sentinel value such as #.
*** Thoughts
    - 找规律。
    - finding leaf, then replace leaf 
*** code
    #+begin_src python
class Solution(object):
    def isValidSerialization(self, preorder):
        """
        :type preorder: str
        :rtype: bool
        """
        if not preorder:
            return False
        
        orders  = preorder.split(',')
        stack = []
        for order in orders:
            stack.append(order)
            while True:
                if len(stack) >= 3 and stack[-1] == '#' and stack[-2] == '#' and stack[-3] != '#':
                    stack.pop()
                    stack.pop()
                    stack.pop()
                    stack.append('#')
                else:
                    break
        if len(stack) == 1 and stack[0] == '#':
            return True
        
        return False                
    #+end_src
*** summary







** 641. Design Circular Deque
*** problem
Design your implementation of the circular double-ended queue (deque).
Your implementation should support following operations:
*** Thoughts
    - use 2 ponter begin, end to track insert/push
*** code
    #+begin_src python
class MyCircularDeque(object):

    def __init__(self, k):
        """
        Initialize your data structure here. Set the size of the deque to be k.
        :type k: int
        """
        self._k = k
        self._queue = [None] * k
        self._begin = 0
        self._end = 0
        self._size = 0
        

    def insertFront(self, value):
        """
        Adds an item at the front of Deque. Return true if the operation is successful.
        :type value: int
        :rtype: bool
        """
        if self._size >= self._k:
            return False 
        
        self._begin = (self._begin - 1 + self._k) % self._k
        self._queue[self._begin] = value
        self._size += 1
        return True

    def insertLast(self, value):
        """
        Adds an item at the rear of Deque. Return true if the operation is successful.
        :type value: int
        :rtype: bool
        """
        if self._size >= self._k:
            return False
        
        self._queue[self._end] =value
        self._end = (self._end +  1) % self._k
        self._size += 1
        return True
        

    def deleteFront(self):
        """
        Deletes an item from the front of Deque. Return true if the operation is successful.
        :rtype: bool
        """
        if self._size == 0:
            return False
        
        self._queue[self._begin] = None
        self._begin = (self._begin + 1 ) % self._k
        self._size -= 1
        return True
        

    def deleteLast(self):
        """
        Deletes an item from the rear of Deque. Return true if the operation is successful.
        :rtype: bool
        """
        if self._size == 0:
            return False
        
        self._end = (self._end - 1 + self._k ) % self._k
        self._queue[self._end] = None
        self._size -= 1
        return True
        

    def getFront(self):
        """
        Get the front item from the deque.
        :rtype: int
        """
        if self._size == 0:
            return -1
        return self._queue[self._begin]
        

    def getRear(self):
        """
        Get the last item from the deque.
        :rtype: int
        """
        if self._size == 0:
            return -1
        return self._queue[self._end-1]
        

    def isEmpty(self):
        """
        Checks whether the circular deque is empty or not.
        :rtype: bool
        """
        return self._size == 0
        

    def isFull(self):
        """
        Checks whether the circular deque is full or not.
        :rtype: bool
        """
        return self._size == self._k
        
    #+end_src
*** summary
    - 看清题目要求



** 659. Split Array into Consecutive Subsequences                     :ERROR:
*** problem
You are given an integer array sorted in ascending order (may contain duplicates), you need to split them into several subsequences, where each subsequences consist of at least 3 consecutive integers. Return whether you can make such a split.
*** Thoughts
*** code
    #+begin_src python

    #+end_src
*** summary




** 767. Reorganize String
*** problem
Given a string S, check if the letters can be rearranged so that two characters that are adjacent to each other are not the same.
If possible, output any possible result.  If not possible, return the empty string.
*** Thoughts
    - how to arange ? 
      - a ... a .. a ...
      - a b .. a b .. a c ..
    - so we can use multiple stacks each stack starting with a ( the most letter ) 
*** code
    #+begin_src python
class Solution(object):
    def reorganizeString(self, S):
        c_map = {}
        for c in S:
            c_map[c] = c_map.get(c, 0) + 1
        
        stacks = []
        c_items = sorted(c_map.iteritems(), key = lambda (k, v) : (v, k), reverse=True)
        stack_len = c_items[0][1]
        for _ in range(stack_len):
            stacks.append([])
        index = 0
        for key, val in c_items:
            for i in range(val):
                stacks[index%stack_len].append(key)
                index += 1
        
        result = ""
        for stack in stacks:
            tmp = ''.join(stack)
            if result and  result[-1] == tmp[0]:
                return ""
            
            result += tmp
        return result 
            
    #+end_src
*** summary


** 735. Asteroid Collision
*** problem
Example 1:
Input: 
asteroids = [5, 10, -5]
Output: [5, 10]
Explanation: 
The 10 and -5 collide resulting in 10.  The 5 and 10 never collide.
*** Thoughts
    - simple stack problem
    - 分类讨论，不一定要想到最巧的方法
*** code
    #+begin_src python
class Solution(object):
    def asteroidCollision(self, asteroids):
        """
        :type asteroids: List[int]
        :rtype: List[int]
        """
        stack = []
        for a in asteroids:
            if a > 0:
                stack.append(a)
                continue
            
            # a < 0
            add = True
            while stack:
                last = stack[-1]
                if last < 0:
                    add = True
                    break
                else:
                    if abs(last) > abs(a):
                        add = False
                        break
                    elif abs(last) < abs(a):
                        add = True
                        stack.pop()
                    else:
                        stack.pop()
                        add = False
                        break
            
            if add:
                stack.append(a)
                        
        return stack 
                
    #+end_src
*** summary




** 743. Network Delay Time
*** problem
There are N network nodes, labelled 1 to N.
Given times, a list of travel times as directed edges times[i] = (u, v, w), where u is the source node, v is the target node, and w is the time it takes for a signal to travel from source to target.
Now, we send a signal from a certain node K. How long will it take for all nodes to receive the signal? If it is impossible, return -1.
*** Thoughts
    - everytime getting the min cost 
      - thinking to use min heap 
*** code
    #+begin_src python
class Solution(object):
    def networkDelayTime(self, times, N, K):
        times_map = {}
        for time in times:
            times_map[time[0]] = times_map.get(time[0], []) + [time]        
        
        visit_map = {}
        
        total = 0
        import heapq
        minheap = [(0, -1, K)]
        while minheap:
            min_edge = heapq.heappop(minheap)
            u = min_edge[1]
            v = min_edge[2]
            w = min_edge[0]
            
            if v in visit_map:
                continue
            
            visit_map[v] = True
            total += w
            
            # update minheap
            for i in range(len(minheap)):
                minheap[i] = (minheap[i][0] - w , minheap[i][1], minheap[i][2])
                
            # finding its neighbor and add them 
            for i, edge in enumerate(times_map.get(v, [])):
                if edge:
                    heapq.heappush(minheap, (edge[2], edge[0], edge[1]))
                    times_map[v][i] = None
        

        if len(visit_map) != N:
            return -1
        
        return total 
        
    #+end_src
*** summary
    - setting visited, need to be careful !
      - in this case, after we pop, do setting visited 


* linked list
** {{{color(red, Medium)}}}
** remove nth node from end of the list 
*** thoughts
    2 pointers 
*** summary
    use Dummy node is the key, it saves a lot of time 

** reverse linked list                                             :reviewed:
*** thoughts 
    the hard part is to reverse it in place
    how to move forward the node ? save next node first 
*** code
#+begin_src python
class Solution(object):
    def reverseList(self, head):
        pre_node = None
        node = head
        while node:
            next_node = node.next    
            node.next = pre_node             
            pre_node = node
            node = next_node
        
        return pre_node
#+end_src
*** summary
   这么简单的题目想复杂了。太不应该了
   保存足够多的temp pointers to iterate 
   dont forget conner case list = []
** merging 2 link list
*** summary
    don't forget move the node: n1 = n1.next

** Palindrome Linked List
*** thoughts
*** code
#+begin_src python
class Solution(object):
    def isPalindrome(self, head):
        """
        :type head: ListNode
        :rtype: bool
        """
        node = head
        result1 = ""
        result2 = ""
        while node:
            result1 = result1 + str(node.val)
            result2 = str(node.val) + result2
            node = node.next
        
        return result1 == result2
#+end_src

** Linked List Cycle                                                   :WARN:
*** thoughts
   classic problem
   2 nodes start at the same postion 
*** code
#+begin_src python
class Solution(object):
    def hasCycle(self, head):
        if head == None:
            return False
        
        node1 = head # starting at the same position 
        node2 = head
        while node1 and node2 and node2.next: 
            node1 = node1.next
            # first check node2.next but it requires node2
            # so check both
            node2 = node2.next.next 
            if node1 == node2:
                return True        
        return False
#+end_src

** intersection linked list
*** thoughts
   - instinct is to use difference
   - find diff, then make the compensatory move
   - get the diff of len(listA) and len(listB)



** add two numbers 
*** Thoughts
    how to create a linked list ?
    - create node
    - link next 
    so, this basically it means you need to save the previous node 
    so, thinking of dummy node 
*** code
     #+begin_src python
class Solution(object):
    def addTwoNumbers(self, l1, l2):
        l = l1
        r = l2
        carry = 0
        dummy = ListNode(-1)
        dummy.next = None # trick 1 
        node = dummy
        
        while l or r: # trick 2 
            left = l.val if l else 0 # need to check if l/r is at the end 
            right = r.val if r else 0
            tmp = left + right + carry 
            new_val = tmp % 10
            carry = tmp / 10  
            node.next = ListNode(new_val)            
            node = node.next
            l = l.next if l else None  # DON'T forget check this !! at last 
            r = r.next if r else None
            
        if carry:    # trick 3, don't forget carry 
            node.next = ListNode(carry)
        
        return dummy.next        
     #+end_src
*** summary
    use dummy node is good approach 


** odd even linked list
*** thoughts 
    so just like reverse linked list, you need to save node.next.next to forward
   - 2 pointers
   - dummy pointer
   - check None (conner cases )
   - check next, next.next. just make sure no nullptr  exception 
*** summary
    use denfensive programming, check node, node.next, node.next.next



** Sort List                                                          :ERROR:
*** problem
Sort a linked list in O(n log n) time using constant space complexity.
*** Thoughts
    - first thinking about quick sort, exceed time limit 
    - merge sort is more easier 
*** code
     #+begin_src python
class Solution(object):
    def sortList(self, head):
        def getmid(head):
            node1 = head
            node2 = head
            while node2 and node2.next and node2.next.next:
                node1 = node1.next
                node2 = node2.next.next
            return node1
        
        def merge(head1, head2):
            dummy = ListNode(-1)
            node = dummy
            while head1 and head2:
                if head1.val < head2.val:
                    node.next = head1
                    head1 = head1.next
                else:
                    node.next = head2
                    head2 =head2.next
                    
                node = node.next
            if head1:
                node.next = head1
            if head2:
                node.next = head2
            return dummy.next        
        
        if head == None:
            return None
        if head.next == None:
            return head            
        
        mid = getmid(head)
        left = head
        right = mid.next
        mid.next = None
        return merge(self.sortList(left), self.sortList(right))
     #+end_src
*** summary
    - 好几个知识点：
      - how to quick sort in-place 
      - how to merge sort merge(sort([:mid]), sort([mid+1:]))
        -merge 2 linklist in place ( no need to use insert, linklist add operation is cheap)
        - how to find the mid ? use 2 pointer 
          - write down examples !!!! what if 1, 2, 3 nodes



** Merge k Sorted Lists
*** problem
    Merge k sorted linked lists and return it as one sorted list.
*** Thoughts
    - merge k linked list, interate each, use an array to save the position node
*** code
     #+begin_src python
class Solution(object):
    def mergeKLists(self, lists):
        """
        :type lists: List[ListNode]
        :rtype: ListNode
        """
        nodes = lists
        dummy = ListNode(-1)
        newnode = dummy
        
        while True:
            min_val = 1000000
            min_i = -1
            for i, l in enumerate(nodes):                                    
                if l and l.val < min_val:
                    min_val = l.val
                    min_i = i
            if min_i == -1:
                break
            
            newnode.next = nodes[min_i]
            newnode = newnode.next
            nodes[min_i] = nodes[min_i].next
            
        return dummy.next
     #+end_src
*** summary
    - could also be solved by merge sort 


** 82. Remove Duplicates from Sorted List II
*** problem
Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list.
Example 1:
Input: 1->2->3->3->4->4->5
Output: 1->2->5

Example 2:
Input: 1->1->1->2->3
Output: 2->3
*** Thoughts
    - keeping old node in order to remove a node
    - dummy node trick 
*** code
    #+begin_src cpp
class Solution {
public:
    ListNode* deleteDuplicates(ListNode* head) {
        if (head == NULL) {
            return head;
        }
        if (head->next == NULL) {
            return head;
        }
        
        ListNode *dummy = new ListNode(-1);
        dummy->next = head;
        ListNode *pre = dummy;
        ListNode *l = head;
        ListNode *r = head->next;
        
        while(pre != NULL && l != NULL && r != NULL){
            if (l->val != r->val){
                pre = pre->next;
                l = l -> next;
                r = r -> next;
                continue;
            }                        
            while(r != NULL && l->val == r->val){
                r = r->next;
            }
            pre->next = r;
            l = r;
            if (r != NULL) {
                r = r-> next;
            }            
        }            
        return dummy->next;                
    }
};
    #+end_src
*** summary




* hash table 
** Copy List with Random Pointer
*** problem
    A linked list is given such that each node contains an additional 
    random pointer which could point to any node in the list or null.
    Return a deep copy of the list.
*** Thoughts
    - use hashtable to store MAP(orginal node -> new node2)
    - so in second iteration, set the node.random correctly 
*** code
    #+begin_src python
class Solution(object):
    def copyRandomList(self, head):
        if not head:
            return None
        
        node_map = {}
        node = head
        dummy = RandomListNode(-1)
        copy = dummy

        while node:         
            copy.next = RandomListNode(node.label)
            node_map[node] = copy.next 
            copy = copy.next
            node = node.next
            
        node = dummy.next
        origin_node = head
        while node:
            r = origin_node.random
            if r:
                node.random = node_map[r]
                        
            node = node.next
            origin_node = origin_node.next
            
        return dummy.next
    #+end_src
*** summary




** Find All Anagrams in a String                                      :ERROR:
*** problem
Given a string s and a non-empty string p, find all the start indices of p's anagrams in s.
Strings consists of lowercase English letters only and the length of both strings s and p will not be larger than 20,100.
*** Thoughts
    - seems a easy approach, go through each letter in s, check s --> s+len(p)
      - use hash to check if it is anagram. O(n*m) time
    - BUT you can see m is compuated repeatly !!!!!!
      - using sliding windows
        - O(n)
*** code
    #+begin_src python
class Solution(object):
    def findAnagrams(self, s, p):
        # defensive 
        if not s:
            return []
        # defensive
        if len(s) < len(p):
            return []
        
        str_len = len(p)
        char_map = {}
        for pc in p:
            if pc in char_map:
                char_map[pc] += 1
            else:
                char_map[pc] = 1
                
        tmp_char_map = {}           
        index = 0
        result = []
        # init
        for i in range(str_len):
            if s[i] in tmp_char_map:
                tmp_char_map[s[i]] += 1
            else:
                tmp_char_map[s[i]] = 1
        
        while index <= len(s)-str_len:
            if tmp_char_map == char_map:
                result.append(index)            
                      
            index = index + 1
            if index > len(s) - str_len:
                break 
                
            # sliding window 
            pre = s[index-1]
            new = s[index+str_len-1]
            if pre in tmp_char_map:   
                tmp_char_map[pre] -= 1
                        
            if new in tmp_char_map:
                tmp_char_map[new] += 1
            else:
                tmp_char_map[new] = 1
            
            if pre in tmp_char_map and tmp_char_map[pre] == 0:
                del tmp_char_map[pre]

        return result
    #+end_src
*** summary
    - How sliding window works ? 
      - everytime moving forward, remove BEGIN, add END
        - so that you don't have to init/recalucate the tmp_dict everytime 


** 4Sum II                                                            :ERROR:
*** problem
Given four lists A, B, C, D of integer values, compute how many tuples (i, j, k, l) there are such that A[i] + B[j] + C[k] + D[l] is zero.
*** Thoughts
    - thinking about 3sum, 2sum
      - so thinking about 4sum -> 2sum, time: O(n^3), BUT THIS IS WRONG
      - A,B,C,D are independent.
        - hash 2sum, O(n^2) -> O(n)
          - hash 4sum -> 2 hash 2sum. 
*** code
    #+begin_src python
class Solution(object):
    def fourSumCount(self, A, B, C, D):
        if not A:
            return 0

        a_b_map = dict([])
        for a in A:
            for b in B:
                a_b = a + b
                if a_b in a_b_map: # if !!!!! not for 
                    a_b_map[a_b] += 1
                else:
                    a_b_map[a_b] = 1
                    
        count = 0     
        for c in C:
            for d in D:
                c_d = c+d
                target = 0 - c_d
                if target in a_b_map:
                    count += a_b_map[target]

        return count 
    #+end_src
*** summary
    - using hash, 空间换时间
    - for regular 4sum, you can do a O(n^2) too, just save index of A,B



* array
** {{{color(red, Easy)}}}
** Plus One
*** summary
   - python array appending 
   - don't forget adding 1 first 
   - don't forget inserting last carry 

** move zero 
*** summary
   - python range(n) = 0, 1, 2, ... n-1
** valid sudoku                                                        :WARN:
*** thoughts 
   - 应用枚举发，先把可能性写下来
   - 难点是How to go through each cell 
*** code 
#+begin_src python
class Solution(object):
    def isValidSudoku(self, board):
        i = 0
        j = 0
        for i in range(len(board)):
            check = {}
            check2 = {}
            check3 = {}
            for j in range(len(board)):
                if board[i][j] in check:
                    return False
                elif board[i][j] != '.':
                    check[board[i][j]] = 1
                    
                if board[j][i] in check2:
                    return False
                elif board[j][i] != '.':
                    check2[board[j][i]] = 1
                
                # key is here, consider i as number not axis.
                # we have i=9 blocks starting at 
                # (0,0) (0,3) (0,6) (3, 0) ... 
                num = board[i/3 * 3 + j/3][i%3 * 3 + j%3]
                if num in check3:
                    return False
                elif num != '.':
                    check3[num] = 1
                                      
        return True                    
#+end_src

** Rotate Image                                                    :reviewed:
*** thoughts
   - do this in-place, 
   - write down the example 
*** code
#+begin_src python
class Solution(object):
    def rotate(self, matrix):
        length = len(matrix)
        # roate 4 points a time, similar to reverse link list problem 
        # to make the problem easy: first 
        """
        tmp = m[0][0]
        m[0][0] = m[n][0]
        m[n][0] = m[n][n]
        m[n][n] = m[0][n]
        m[0][n] = tmp
        after that, considering + offset 
        after that, considering go deeper m[0][0] --> m[i][i+offset]
        (0 ---> i; n ---> n-i)
        """
        for i in range(length-1):
            offset = 0
            while i + offset < length - 1 - i:
                tmp = matrix[i][i + offset]
                matrix[i][i + offset] = matrix[length - 1 - offset-i][i]
                matrix[length - 1 - offset-i][i] = matrix[length - 1-i][length - 1 - offset-i ]
                matrix[length - 1-i][length - 1 - offset-i] = matrix[i + offset ][length - 1 -i]
                matrix[i + offset ][length - 1 -i] = tmp
                offset += 1
#+end_src
*** summary
   - 完全不会做 ！
   - matrix就是薄弱环节


** Find All Numbers Disappeared in an Array
*** Thoughts
    - using extra space is easy, how to use constant space ? 
    - 这个数组有什么特点？想到number和index有对应关系
      - if number not exist, that index will be related
*** code
     #+begin_src python
class Solution(object):
    def findDisappearedNumbers(self, nums):
        for num in nums:
            nums[abs(num)-1] = abs(nums[abs(num)-1]) * -1
            
        res = []
        for i, num in enumerate(nums):
            if num > 0:
                res.append(i+1)
        
        return res
     #+end_src
*** summary
    - 非常巧妙的方法，把数字和index联系起来


** Container With Most Water
*** Thoughts
    - looks like a 2 pointers problem 
    - so question is, how to move pointer ?
    - greedy approach, always move the shorter one 
*** code
     #+begin_src python
class Solution(object):
    def maxArea(self, height):
        """
        :type height: List[int]
        :rtype: int
        """
        i = 0
        j = len(height) - 1
        res = 0
        while i < j:
            ai = height[i]
            aj = height[j]
            tmp = min(ai, aj) * (j - i)
            res = tmp if tmp > res else res
            
            if ai < aj:           
                i += 1
            else:         
                j -= 1
                
        return res
     #+end_src
*** summary
    greedy algorithm, Time: O(n)

** find duplicate numbers                                             :ERROR:
*** problem
Given an array nums containing n + 1 integers where each integer is between 1 and n (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one.
*** Thoughts
    - use sorting, need to change array or extra space
    - use map, extra space 
    - without both, problem is hard
*** code
     #+begin_src python
class Solution(object):
    def findDuplicate(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        i = 0
        j = len(nums) - 1
        
        while i < j:
            mid = (i + j) /2
            
            count = 0
            for num in nums:
                if num <= mid:
                    count += 1
            if count <= mid:
                i = mid + 1
            else:
                j = mid
       
        return i 
     #+end_src
*** summary
    - 理解题目出现错误. 这是一个抽屉原理题目
    - brute for is to check if each target in for num in nums
    - using binary serach, instad of looping through target, do binray search


**  Search Insert Position
*** problem
Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.
*** Thoughts
    - simple binary serach 
*** code
    #+begin_src python
class Solution:
    def searchInsert(self, nums, target):        
        l = 0
        r = len(nums) -1
        while l <= r:
            mid = l + int((r-l)/2)
            if nums[mid] < target:
                l = mid + 1 
            elif nums[mid] > target:
                r = mid - 1
            else:
                return mid
            
        return r + 1
    #+end_src
*** summary




** {{{color(red, Medium)}}}

** Maximum Product Subarray                                            :WARN:
*** problem
Given an integer array nums, find the contiguous subarray within an array (containing at least one number) which has the largest product.
*** Thoughts
    - thinking about DP.
    - the substring ending with N
*** code
    #+begin_src python
class Solution(object):
    def maxProduct(self, nums):
        if not nums:
            return None
        
        pstates = [None] * len(nums)
        nstates = [None] * len(nums)
        
        if nums[0] > 0:
            pstates[0] = nums[0]
        elif nums[0] < 0:
            nstates[0] = nums[0]
        else:
            pstates[0] = 0
            nstates[0] = 0
        
        for i in range(1, len(nums)):                                    
            if nums[i] > 0: 
                if pstates[i-1]:
                    tmp = pstates[i-1] * nums[i]
                    pstates[i] = tmp if tmp > nums[i] else nums[i]
                else:
                    pstates[i] = nums[i]
                    
                if nstates[i-1]:
                    tmp1 = nstates[i-1] * nums[i]
                    nstates[i] = tmp1
                    
            elif nums[i] < 0:
                if pstates[i-1]:
                    tmp = pstates[i-1] * nums[i]
                    nstates[i] = tmp if tmp < nums[i] else nums[i]
                else:
                    nstates[i] = nums[i]
                if nstates[i-1]:
                    tmp1 = nstates[i-1] * nums[i]
                    pstates[i] = tmp1
            else:
                pstates[i] = 0
                nstates[i] = 0
                    
                    
        maxp = -1000000            
        for p in pstates + nstates:
            maxp = p if p > maxp else maxp
            
        return maxp
    #+end_src
*** summary
    - use straight forward implementation 
    - 不要取巧，直接用None来初始化state table

** Spiral Matrix
*** problem
Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order.
*** Thoughts
    - 找规律, find the common law
    - matrix problem, write down the first interation, then adding K 
    - Exit condition ? 
*** code
    #+begin_src python
class Solution(object):
    def spiralOrder(self, matrix):
        if not matrix:
            return []
        
        im = len(matrix)
        jn = len(matrix[0])
        res = []
        k = 0
        count = 0
        while True:               
            for j in range(k, jn-k):
                res.append(matrix[k][j])
                count += 1
            
            if count >= im * jn:
                break
                        
            for i in range(k+1, im - k):
                res.append(matrix[i][jn-1-k])
                count += 1
                
            if count >= im * jn:
                break                
                
            for j in range(jn-1-1-k, -1+k, -1):
                res.append(matrix[im-1-k][j])
                count += 1
                
            if count >= im * jn:
                break
                
            for i in range(im-1-1-k, 0+k, -1):
                res.append(matrix[i][0+k])
                count += 1
            
            if count >= im * jn:
                break                            
            k += 1
        return res
                    
    #+end_src
*** summary
    - How to Exit ? a easy way is to check the number of result array 
    - array problem, always has corner cases 



** Minimum Path Sum
*** problem
Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path.
*** Thoughts
    - obviously it's a DP problem 
*** code
    #+begin_src python
class Solution(object):
    def minPathSum(self, grid):
        # f(i, j ) = f(i-1, j) or f(i, j-1)
        if not grid:
            return 0
            
        r_num = len(grid)
        c_num = len(grid[0])
        
        state = [[None] * c_num for _ in range(r_num)]
        
        k = 0
        state[0][0] = grid[0][0]
        
        while k < r_num and k < c_num:
            for j in range(k, c_num):
                if k == 0:
                    if j > 0:
                        state[0][j] = state[0][j-1] + grid[0][j]
                else:
                    state[k][j] = min(state[k-1][j], state[k][j-1]) + grid[k][j]
                
            for i in range(k, r_num):
                if k == 0:
                    if i > 0:
                        state[i][0] = state[i-1][0] + grid[i][0]
                else:
                    state[i][k] = min(state[i-1][k], state[i][k-1]) + grid[i][k]                
            k += 1         
        return state[r_num-1][c_num-1]
    #+end_src
*** summary
    - don't have traverse matrix like this. could do it in order

** Subarray Sum Equals K                                              :ERROR:
*** problem
Given an array of integers and an integer k, you need to find the total number of continuous subarrays whose sum equals to k.
Example 1:
Input:nums = [1,1,1], k = 2
Output: 2
*** Thoughts
    - brute force + state array 
    - at first thinking about i,j 
      - better solution: sum(i) - sum(j) == k 
    - best solution, using map to save sum_state for quick access 
*** code
    #+begin_src python
class Solution(object):
    def subarraySum(self, nums, k):
        count = 0
        sum_map = { 0 : 1 }
        sum = 0
        for i in range(len(nums)):
            sum += nums[i]
            if sum - k in sum_map:
                count += sum_map[sum-k]
            
            sum_map[sum] = sum_map.get(sum, 0) + 1
        
        return count 
    #+end_src
*** summary
    - n^2 brute force can usally converted to 1 dimension state array 
    - 求和，考虑反其道，看看能不能用减法
      - for example, 2 sum, 3 sum 

** Next Permutation                                                   :ERROR:
*** problem
Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.
*** Thoughts
    - 只能想到brute force
*** code
    #+begin_src python
class Solution:
    def nextPermutation(self, nums):
        def reverse(index, nums):  # could also using sorting 
            i = index
            j = len(nums) -1
            while i < j:
                nums[i], nums[j] = nums[j], nums[i]
                i += 1
                j -= 1
        
        # find first descending from right 
        i = len(nums) - 2
        while i >= 0 and nums[i] >= nums[i+1]:
            i -= 1
            
        # find the one just larger 
        j = len(nums) - 1
        while j >= 0 and nums[j] <= nums[i]:
            j -= 1
        
        if i >= 0 and i >=0:
            nums[i], nums[j] = nums[j], nums[i]
        
        # reverse i + 1
        reverse(i+1, nums)                        
    #+end_src
*** summary
    - while loop, still forget ++ or -- 
    - 找规律类型题目还是不行啊



** Game of life
*** Thoughts
    - doing this in place is hard part
      - thinking to change the val in matrix to antoher then
        map it back 
*** code
     #+begin_src python
class Solution(object):
    def gameOfLife(self, board):
        def live(val):
            # 0 -> 0, 1 -> 1,
            # 00 -> 2, 01 -> 3, 10 -> 4, 11 -> 5
            if val == 0 or val == 2 or val== 3:
                return False
            else:
                return True
        
        def new_live(val):
            if val == 1 or val == 3 or val == 5:
                return True
            else:
                return False
        
        
        if not board:
            return
            
        m = len(board)
        n = len(board[0])
        
        for i in range(m):
            for j in range(n):
                current_val = board[i][j]
                count_live = 0
                count_dead = 0
                for ik in range(i-1, i+2):
                    for jk in range(j-1, j+2):
                        if ik == i and jk == j:
                            # current cell
                            pass
                        elif ik >= 0 and ik < m and jk >= 0 and jk < n:
                            val = board[ik][jk]
                            if live(val):
                                count_live += 1
                            else:
                                count_dead += 1
                                
                if live(current_val) and count_live < 2:
                    # dead
                    board[i][j] = 4
                    
                elif live(current_val) and count_live >=2 and count_live <=3:
                    # live
                    board[i][j] = 5
                    
                elif live(current_val) and count_live > 3:
                    # dead
                    board[i][j] = 4
                elif not live(current_val) and count_live == 3:
                    # live 
                    board[i][j] = 3
                    
        for i in range(m):
            for j in range(n):
                val = board[i][j]
                if new_live(val):
                    board[i][j] = 1
                else:
                    board[i][j] = 0
               
     #+end_src
*** summary
    - very good, 一遍通过
    - corner case first. defensive programming  
    - use small functions. 
    - write comments to avoid bugs 




** shuffle array                                                   :reviewed:
*** thoughts
   - straght forward solution, use random.randrange()
   - python pass by reference, when in doubt, deepycopy
*** code
#+begin_src python
class Solution(object):
    def __init__(self, nums):
        self._nums = nums
        self._original = list(nums) # python need to take care of deepy copy
        

    def reset(self):
        self._nums = list(self._original) # deepcody 
        return  self._nums

    def shuffle(self):
        for i in range(len(self._nums)):
            swapidx = random.randrange(i, len(self._nums))
            self._nums[i], self._nums[swapidx] = self._nums[swapidx], self._nums[i]
                
        return self._nums
#+end_src

*** summary
   - Be aware of member variable, you need to reset it after calling function
   - 严重超时。
   - this is "Fisher-Yates Algorithm"

** generate all possible combinations
#+begin_src python
def gen(nums):
    if len(nums) == 0:
        return []
    if len(nums) == 1:  # no harm to add more exit condition
        return [nums]
    
    result = []
    for num in nums:
        left = ... 
        for comb in gen(left):
             result.append([num] + comb)

    return result
#+end_src


 




** Increasing Triplet Subsequence
*** problem
Return true if there exists i, j, k 
such that arr[i] < arr[j] < arr[k] given 0 ≤ i < j < k ≤ n-1 else return false.
*** thoughts
    - Be careful, always use explcit MAX
    - 不要图省事，用一个大数字，数字一般不够大的 ！！
*** code 
#+begin_src python
class Solution:
    def increasingTriplet(self, nums):
        INT_MAX = 2 ** 32
        min1 = INT_MAX
        min2 = INT_MAX
        min3 = INT_MAX
        for num in nums:
            if num <= min1:
                min1 = num
            elif num <= min2:
                min2 = num
            elif num <= min3:
                min3 = num
        
        return min1 != INT_MAX and min2 != INT_MAX and min3 != INT_MAX
#+end_src

**  {{{color(red, OTHERS)}}}
** 162 peak number
*** problem 
 A peak element is an element that is greater than its neighbors.
 Given an input array where num[i] ≠ num[i+1], find a peak element and return its index.
 The array may contain multiple peaks, in that case return the index to any one of the peaks is fine.
 You may imagine that num[-1] = num[n] = -∞.
 For example, in array [1, 2, 3, 1], 3 is a peak element and your function should return the index number 2.
 click to show spoilers.
 Credits:
 Special thanks to @ts for adding this problem and creating all test cases.

*** hint
 INT_MIN vs INT_MAX



** 153 min in rotated sorted array
 Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.
 (i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).
 Find the minimum element.
 You may assume no duplicate exists in the array.

*** hint
 always think about 'else case' when coding


** 2 sum 
 Given an array of integers,
 find two numbers such that they add up to a specific target number.
*** hint
    - if the array is sorted, then use 2 pointer is better solution 
    - remeber this probelm is retunning indices, not the acutal number 
     
*** code 
 #+BEGIN_SRC python
 class Solution(object):
     def twoSum(self, nums, target):
         """
         :type nums: List[int]
         :type target: int
         :rtype: List[int]
         """
         map = {}
         for i, num in enumerate(nums): 
             if target - num in map:
                 return [ map[target - num], i ]
             else:
                 map[num] = i

         return []
 #+END_SRC


** palindrome integer
 palindrome integer is 121, 112211

*** hint
  the key is to check if the number overflows

*** code 
 #+BEGIN_SRC cpp
 class Solution {
 public:
     bool isPalindrome(int x) {
         int sum = 0;
         int origin = x;
         while(x > 0) {     
             if (sum  > origin/10) // check if it overflows 
                 return false;
            
             sum = sum * 10 + x % 10;                        
             x = x /10;             
         }
         return sum == origin;
     }
 };
 #+END_SRC

** implement strstr
*** hint 
 corner case:
 "" ""
 "a" "b"
*** code 
 #+BEGIN_SRC cpp
 class Solution {
 public:
     int strStr(string haystack, string needle) {
         for (int i = 0; ; i ++ ) { // no need to set the boundary 
             for (int j = 0; ; j++) {
                 if (j == needle.size()){ // check it first, to avoid conner case
                     return i;
                 }
                 if (i+j == haystack.size()) return -1;

                 if (haystack[i + j] != needle[j]){ 
                     // compare i+j, so if not work, backtrace to i 
                     break;
                 }                
             }            
         }      
     }
 };
 #+END_SRC




* string
** {{{color(red, Easy)}}}
** Reverse String                                                  :reviewed:
*** thoughts
    - simple solution
*** code 
#+begin_src python
    def reverseString(self, s):
        # [begin:end:step]
        # python string is inmutable
        return s[::-1]
#+end_src

** reverse integer                                                     :WARN:
*** thoughts
   - consider overflow 
   - max singed integer 2³¹-1
   - python power 2**31

** First Unique Character in a String                                  :WARN:
*** thoughts 
   - use straght-foward solution first !!!!
   - O(n)
*** code 
#+begin_src python
class Solution(object):
    def firstUniqChar(self, s):
        map = {}
        for i, c in enumerate(s):
            if c not in map:
                map[c] = i  # save the index
            else:
                map[c] = len(s)
                
        
        min = len(s)
        for key in map:
            if map[key] < min:
                min = map[key]
        
        if min == len(s):
            return -1
        else:
            return min
#+end_src

** Valid Anagram
*** thoughts
   - if no unicode, we could use a array whose index is char - 'a'
*** summary

** Valid Palindrome                                                    :WARN:
   - python check isalnum
   - HAVING LOOP, CONSIDER EXIT ( avoid infinite loop ) 
#+begin_src python
class Solution(object):
    def isPalindrome(self, s):
        begin = 0
        end = len(s) - 1
        while begin < end:
            while not s[begin].lower().isalnum() and begin < end:
            # use while to pass invalid chars 
                begin = begin + 1
                
            while not s[end].lower().isalnum() and begin < end:
                end = end - 1            
                
            if begin < end and s[begin].lower() != s[end].lower():
                return False
            
            begin = begin + 1
            end = end - 1
            
        return True
            
        
#+end_src

** implement strStr()
   - corner case ""
   - pre-check to ingore cases not possible, this saves time

** atoi                                                                :WARN:
   - overflow: positive/negtive
   - invalid string
   - signed
   - empty 
   - white space
#+begin_src python
class Solution(object):
    def myAtoi(self, str):
        # overflow problem 
        # invalid 
        # negtive         
        if len(str) == 0:
            return 0
        str = str.strip(' ')        
        signed = 1
        if str[0] == '-':
            signed = -1
            str = str[1:]
        elif str[0] == '+':  #能用if-else就用
            str = str[1:]
            
        MAX = 2**31 - 1
        MIN = -2**31
        result = 0
        for s in str:
            if not s.isdigit():
                return signed * result
            
            d = int(s)            
            if signed == 1 and result > (MAX - d)/10:
                return MAX
            
            if signed == -1 and result > (-1 * MIN - d)/10:
                return MIN
            
            result = result * 10 + d # += --> ++ do not use it often                         
        return signed * result
#+end_src


** longest common prefix                                               :WARN:
*** thoughts
    conner case, what if list is empty
*** summary
   - be ware of corner case
   - 不要咬指甲！！！ 

** count and say
*** thoughts
    - logic is easy, just be aware of conner case
*** code 
#+begin_src python
class Solution(object):
    def countAndSay(self, n):
        def cal(a):
            # 111221
            if len(a) == 0:
                return ''            
            count = 1
            pre = a[0]
            result = ''
            for c in a[1:]:
                if c == pre:
                    count += 1
                else:
                    result += str(count) + pre
                    pre = c
                    count = 1
            
            result += str(count) + pre
            return result  # forget return type 
                    
        a = [None] * (n+1)   # pythonic reserve 
        for i in range(n+1):
            # a[i] = cala[i-1]
            if i == 0:
                a[0] = ''
            if i == 1:
                a[1] = '1'
            if i > 1:
                a[i] = cal(a[i-1])
            
        return a[n]            
#+end_src
*** summary
   - when writing a function:
     - check signiture
     - check return 
     - check exit condition if recursive 
       - no harm to add more exit condition (defensive programming)


** Group Anagrams
   - better solution ?

** Longest Substring Without Repeating Characters                      :WARN:
    - python while/for, do not forget i += 1
#+begin_src python
class Solution(object):
    def lengthOfLongestSubstring(self, s):
        startpos = 0
        lsubl = 0
        
        while startpos < len(s):
            used = {}
            subl = 0
            prev_idx = len(s) # a place holder value 
            c_i = startpos
            while c_i < len(s):
                c = s[c_i]
                if c not in used:
                    subl += 1
                    used[c] = c_i
                else: 
                    prev_idx = used[c]
                    break
                c_i += 1    # DONT FORGET THIS
                    
            lsubl = subl if subl > lsubl else lsubl
            startpos = prev_idx + 1 
        
        return lsubl
#+end_src


** Basic Calculator II
*** problem
Implement a basic calculator to evaluate a simple expression string.
The expression string contains only non-negative integers, +, -, *, / operators and empty spaces . The integer division should truncate toward zero.
*** Thoughts
    - 2 passes, first do +/-, then do *//
*** code
     #+begin_src python
class Solution(object):
    def calculate(self, s):
        ops = []
        nums = []
        curr = 0
        for c in s:
            if c == ' ':
                continue
                
            if c == '+' or c == '-' or c == '*' or c == '/':
                ops.append(c)
                nums.append(curr)
                curr = 0
            else:
                curr = curr * 10 + int(c)  
        nums.append(curr)
        
        num_idx = 0
        for op in ops:
            if op == '*':
                tmp = nums[num_idx] * nums[num_idx+1]
                nums[num_idx] = tmp
                nums.pop(num_idx+1)
            elif op == '/':
                tmp = int(nums[num_idx] / nums[num_idx+1])
                nums[num_idx] = tmp
                nums.pop(num_idx+1)   
            else:
                num_idx += 1
                
        num_idx = 0  
        result = 0
        for op in ['+']+ops:
            if op == '+':
                result = result + nums[num_idx]
                num_idx += 1
            if op == '-':
                result = result - nums[num_idx]
                num_idx += 1
        return result 
     #+end_src
*** summary




** Decode Ways
*** problem
A message containing letters from A-Z is being encoded to numbers using the following mapping
*** Thoughts
    - obvious DP problem 
    - calculate state[0], state[1]
      - considering calculate 1 in the loop, just add extra condition in the loop
*** code
    #+begin_src python
class Solution(object):
    def numDecodings(self, s):
        if len(s) == 0:
            return 0
        
        # ending with n 
        # f(n) = f(n-1) + (f(n-2) if nn-1 in map
        numEnding = [0] * (len(s) )                
        numEnding[0] = 1 if s[0] != '0' else 0
        
        index = 1
        while index < len(s):
            tmp2 = 0
            val = int(s[index-1:index+1])
            if val <= 26 and val >= 10:
                if index == 1:
                    tmp2 = 1
                else:
                    tmp2 = numEnding[index-2]
            
            tmp1 = 0
            val1 = int(s[index])
            if val1 != 0:
                tmp1 = numEnding[index-1]
            
            numEnding[index] = tmp1 + tmp2
            index += 1
            
        return numEnding[len(s)-1]
    #+end_src
*** summary
    - note 0 is invalid, so 26 >= XX >= 10, X > 0 


** Reverse Words in a String
 Given s = "the sky is blue",
 return "blue is sky the".
*** hint
 need to reduce the space, we could retrieve the word 
*** code 
 #+BEGIN_SRC cpp
 class Solution {
 public:
     void reverseWords(string &s) {
         vector<string> words;
         string word;
         for (int i = 0; i < s.size(); i++){
             if (s[i] != ' ') {
                 word += s[i];
             } else {
                 if (!word.empty())
                     words.push_back(word);
                     word = ""; // reset string, don't use clear()
             }
         }
         if (!word.empty())
             words.push_back(word);
        
         s ="";
         for (int i = words.size() - 1; i> 0; i--){
             s = s +  words[i] + " ";
         }
         if (words.size() > 0) // check before accessing an array 
             s += words[0];
        
     }
 };
 #+END_SRC

** reverse words 2 

**  Longest Substring Without Repeating Characters
 Given "abcabcbb", the answer is "abc", which the length is 3.
*** hint 
    - use map to save the index
    - compare start < indexMap

*** code
 #+begin_src cpp
 class Solution {
 public:
     int lengthOfLongestSubstring(string s) {
         // sliding window, change the start point 
         // another solution is to 
         int start  = 0;
         map<char, int> charMap;
         int maxLen = 0;
         for ( int i = 0; i< s.size() ; i++) {
             if (charMap.find(s[i]) != charMap.end() && charMap[s[i]] >= start) {
                 // unable to find the char 
                 start =  charMap[s[i]] + 1;
             } 
             charMap[s[i]] = i;
             maxLen = maxLen > (i - start + 1) ? maxLen : (i - start + 1);
         }
         return maxLen;
     }
 };
 #+end_src




* trees

** 230 Kth Smallest Element in a BST
 Given a binary search tree, write a function kthSmallest to find the kth smallest element in it.

 Note: 
 You may assume k is always valid, 1 ≤ k ≤ BST's total elements.

 Follow up:
 What if the BST is modified (insert/delete operations) often and you need to find the kth smallest frequently? How would you optimize the kthSmallest routine?
*** hint 
   - inorder traversal
   - nothing much 



** max depth of binary tree
   finish in time
** valid BST
   finish in time, having some slight troube doing python

** symmtric tree                                                       :WARN:
   stuck on this problem for a while.
   思维定势了，一开始想直接递归，但发现和subtree问题根本没关系
#+begin_src python
class Solution(object):
    def isSymmetric(self, root):
        if root == None:
            return True        
        return self.traverse(root.left, root.right)
    
    def traverse(self, left, right): # how to compare the val parallelly ? recursion
        if left == None and right == None:
            return True
        
        elif left == None or right == None:
            return False
        
        if left.val != right.val:
            return False
        
        return self.traverse(left.left, right.right) and 
        self.traverse(left.right, right.left) # don't forget compare another branch    
#+end_src

** binary tree level order traverse
   check if array has index i? check the length of the array 
   python data structre 

** sorted array to BST                                             :reviewed:
   didn't come up with the solution
   recursive solution, get the mid value everytime 
   building tree is different from traverse tree, don't confuse 


** Merge Two Binary Trees   
*** Thoughts
    - simple merge 
*** summary
    - everytime doing node.left/right, check if node is NULL (defensive)


** Convert BST to Greater Tree    
*** Thoughts
    - Note it is a BST tree
    - post-in-order traversal 
*** summary
**** TODO review in order traversal's iterate solution


** Diameter of Binary Tree                                            :ERROR:
*** Thoughts
    - you have to compare a lot of nodes 
    - for each node, how to find the longest diameter ?
      - left + right 
*** code
     #+begin_src python
class Solution(object):
    def diameterOfBinaryTree(self, root):
        def getmaxdepth(node):
            if node == None:
                return 0
                        
            left = getmaxdepth(node.left)
            right = getmaxdepth(node.right)
            return max(left, right) + 1
        
        self.res = 0
        def visit(node):
            if node == None:
                return 
            
            # go through node
            left = 0
            if node.left:
                left = getmaxdepth(node.left) 
            right = 0
            if node.right:
                right = getmaxdepth(node.right) 
                
            self.res = max(right + left, self.res)
            
            visit(node.left)
            visit(node.right)
            
        visit(root)
        return self.res
     #+end_src
*** summary
    - for each node, find the longest path which goes through that node
    - a non empty node's max depth is 1, 不要多加 ！


**  Subtree of Another Tree
*** summary
    - 千万不要偷懒，永远defensive programming



** Path Sum III
**** Thoughts
     - for a tree calcute the path use node as root 
     - dfs each node 
**** code
     #+begin_src python
 class Solution(object):
     def pathSum(self, root, sum):
         def path_node_as_root_sum(node, sum):  # focus on this function 
             if node == None:
                 return 0
            
             count = 0
             if sum == node.val:  # if current node meets condition should we cointinue ? 
                 count =  1
                
             left_n = path_node_as_root_sum(node.left, sum - node.val)
             right_n = path_node_as_root_sum(node.right, sum - node.val)
             return left_n + right_n + count
        
         if root == None:
             return 0
         return ( path_node_as_root_sum(root, sum) + 
                 self.pathSum(root.left, sum ) + 
                 self.pathSum(root.right, sum ) )                        
     #+end_src
**** summary
     - in each recursive function, we should focus on that 
       - so when sum == node.val, THATS NOT THE END. DONT RETURN 
         - it means root it self meets requirement 





-----------------------

** 98 Validate Binary Search Tree
 Given a binary tree, determine if it is a valid binary search tree (BST).
 Assume a BST is defined as follows:

 The left subtree of a node contains only nodes with keys less than the node's key.
 The right subtree of a node contains only nodes with keys greater than the node's key.
 Both the left and right subtrees must also be binary search trees.
 Example 1:
     2
    / \
   1   3
 Binary tree [2,1,3], return true.
 Example 2:
     1
    / \
   2   3
 Binary tree [1,2,3], return false.

*** hint 
 - classic problems. 
 - be aware of typo. check typo first 


** binary tree in order traverse (iterative)                   :ERROR:review:
    - traverse a tree like a link-list node = node.left
    - antoher solution ? 
    - 复习了还是不会 ！
    - we are using stack to store parent node 
      - stack served as STATE
    - exit condition is not len(stack) == 0
    - in order is different from post-pre-order
      - in order: insert 1 node each time, use current node + stack 
      - post order: insert 2 nodes each time, use 2 stacks 
#+begin_src python
class Solution:
    def inorderTraversal(self, root):
        if root == None:
            return []
        
        result = []
        queue = []
        node = root
        while True:  # use while true condition in queue/stack problem
            if node:  
                queue.append(node)
                node = node.left
            else:
                if (len(queue) == 0):
                    return result
                top = queue.pop()
                result.append(top.val)
                node = top.right
                                            
#+end_src
** Binary Tree Zigzag Level Order Traversal                            :WARN:
    - 想复杂了。一开始就钻牛角尖，放入queue都时候不需要reverse
    - same as the normal level order traversel, only diffence is insert/append
      when pop up 
    - 2 ways to do in order traversal: recursive/iterative
#+begin_src python
class Solution:
    def zigzagLevelOrder(self, root):
        if root == None:
            return []
        
        result = []
        queue = []
        depth = 0
        queue.append((root, 0))
        while queue:
            front, depth = queue.pop(0)
            if (len(result) == depth):
                result.append([])
            
            if depth % 2 == 0:
                result[depth].append(front.val)
            else:
                result[depth].insert(0,front.val)
                
            if front.left:
                queue.append((front.left, depth + 1))
            if front.right:
                queue.append((front.right, depth + 1))
                
        return result        
#+end_src
** Construct Binary Tree from Preorder and Inorder Traversal           :WARN:
    - a[-n] be aware of n = 0
    - the best practice is to not using a[-n] unless n has a exact number
#+begin_src python
class Solution:
    def buildTree(self, preorder, inorder):
        if not preorder:
            return None 
        if not inorder:
            return None
       
        root_val = preorder[0]
        root = TreeNode(root_val)  #粗心了
        # find root in inorder
        root_index = inorder.index(root_val)
        left_num = root_index
        
        # use a[-n] with cautious
            
        root.left = self.buildTree(preorder[1:1+left_num], inorder[:root_index])
        root.right = self.buildTree(preorder[1+left_num:], inorder[root_index+1:])
            
        
        return root
#+end_src
** Populating Next Right Pointers in Each Node
    - utlize the exsiting NEXT pointer
    - always need to check if pointer exists before using it 
#+begin_src python
class Solution:
    def connect(self, root):
        if not root:
            return 
        
        if not root.left or not root.right: # leaf
            return 
        
        root.left.next = root.right
        if root.next:
            root.right.next = root.next.left
        else:
            root.right.next = None
            
        self.connect(root.left)
        self.connect(root.right)                
#+end_src

** Kth Smallest Element in a BST
   - convert the problem to an in-order traverse
*** code
#+begin_src python
class Solution:
    def kthSmallest(self, root, k):
        res = []
        stack = []
        node = root
        while True:
            if len(res) == k:
                return res[k-1]

            if node:
                stack.append(node)
                node = node.left
            else:  
                top = stack.pop()
                res.append(top.val)
                node = top.right
                
        return None
        
#+end_src


**  Serialize and Deserialize Binary Tree                             :ERROR:
    - tree traverse not good 
      - BFS, DFS
      - pre-order, in-order, post-order
#+begin_src python
class Codec:
# BFS: use a queue to achieve BFS
    def serialize(self, root):
        if not root:
            return None
        
        queue = [root]
        res = []
        while queue:
            top = queue.pop(0)
            if top == None:
                res.append(None)
            else:
                res.append(top.val)
                
            if top:
                queue.append(top.left)
                queue.append(top.right)
            
        return json.dumps(res)
        

    def deserialize(self, data):
        if not data:
            return None
        
        array = json.loads(data)        
        index = 0
        root = TreeNode(array[0])
        queue = [root]
        while queue:   #
            if index >= len(array):
                break
            
            node = queue.pop(0)
            if node:
                index += 1
                node.left = TreeNode(array[index]) if index < len(array) and array[index] != None  else None
                index += 1
                node.right = TreeNode(array[index]) if index < len(array) and array[index] != None else None
                
                queue.append(node.left)
                queue.append(node.right)
        return root
#+end_src
** number of islands                                                  :ERROR:
   - graph dfs !!!
   - naive soution is O(n^2), which is bad. graph solution is O(n*k)
   - be careful about the input type, is it string or int ?
*** code
#+begin_src python
class Solution:
    def numIslands(self, grid):
        if not grid:
            return 0
        
        self.m = len(grid)
        self.n = len(grid[0])
        visited = [[False] * self.n for _ in range(self.m)]
        islands = []
        count = 0
        for i in range(self.m):
            for j in range(self.n):
                # when to start running dfs
                #dont forget check if is 1
                if not visited[i][j] and grid[i][j] == '1':  
                    self.dfs(i, j, grid, visited)
                    count += 1
        return count 
    
    def dfs(self, i, j, grid,visited):
        if visited[i][j]:
            return 
        
        visited[i][j] = True        
        if i + 1 < self.m and grid[i+1][j] == '1':
            self.dfs(i+1, j, grid, visited)
        
        if i > 0 and grid[i-1][j] == '1':
            self.dfs(i-1, j, grid, visited)
            
        if j + 1 < self.n and grid[i][j+1] == '1':
            self.dfs(i, j + 1, grid, visited)
            
        if j > 0 and grid[i][j-1] == '1':
            self.dfs(i, j - 1, grid, visited)
                    
#+end_src






** Lowest Common Ancestor of a Binary Tree
*** Thoughts
    - convert the problem to a tree traversal
    - backtracking
*** code
     #+begin_src python
class Solution(object):
    def lowestCommonAncestor(self, root, p, q):
        self.result1 = []
        self.result2 = []
        self.path = []
        def findNode(node):
            if node == None:
                return
            
            self.path.append(node)
            
            if not self.result1 and node == p:
                self.result1 = list(self.path)  # deepcopy !!
            
            if not self.result2 and node == q:
                self.result2 = list(self.path)
            
            if self.result1 and self.result2:
                return 
            
            findNode(node.left)
            findNode(node.right)
            self.path.pop() # push 1, pop 1, basic back tracking 
        

        findNode(root)
        LCA = None
        for i in range(min(len(self.result1), len(self.result2))):
            if self.result1[i] == self.result2[i]:
                LCA = self.result1[i]
            else:
                break
        return LCA                
     #+end_src
*** summary
    - always thinking deepy copy when doing object assignment (defensive)
    - back tracking, 1 push 1 pop
      Fun A
        Fun B
          Fun null
          Fun null
          pop()  -- B
        Fun C
        ...


** House Robber III
*** Thoughts
    - 太牛逼了，这个想不到啊
*** code
    #+begin_src python
class Solution(object):
    def rob(self, root):
        def dfs(node):
            if node == None:
                return (0, 0)
            
            left = dfs(node.left)
            right = dfs(node.right)
            
            max_chose_node = left[1] + right[1] + node.val
            max_not_chose_node = max(left[0], left[1]) + max(right[0], right[1])
            return (max_chose_node, max_not_chose_node)
        
        res = dfs(root)
        return max(res[0], res[1])
    #+end_src
*** summary

** Unique Binary Search Trees                                         :ERROR:
*** Thoughts
*** code
     #+begin_src python
class Solution(object):
    def numTrees(self, n):
        f = [0] * (n+2)
        f[0] = 1
        f[1] = 1
        for i in range(2, n+1):
            for offset in range(0, i):
                f[i] += f[i-1 - offset] * f[offset]
                
        return f[n]
     #+end_src
*** summary



** Flatten Binary Tree to Linked List
*** Thoughts
    - thinking of dfs traversal 
*** code
    #+begin_src python
    #+end_src
*** summary




* graph
** {{{color(red, Medium)}}}
** course schedule II
*** problem
Input: 4, [[1,0],[2,0],[3,1],[3,2]]
Output: [0,1,2,3] or [0,2,1,3]
Explanation: There are a total of 4 courses to take. 
To take course 3 you should have finished both     
courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0. 
So one correct course order is [0,1,2,3]. Another correct ordering is [0,2,1,3] 
*** Thoughts
    - simmilar to course schedule I
    - Topological sort
      - DFS, then push black to the beginning of a queue 
*** code
    #+begin_src python
class Solution:
    def findOrder(self, numCourses, prerequisites):
        self.hascyc = False
        self.result = []
        self.visited  = [0] * numCourses
        self.grey = [0] * numCourses
        self.black = [0] * numCourses
        
        # node is index from 0 to N-1
        def visit(node):
            if self.hascyc:
                return 
        
            # visit the node
            self.visited[node] = 1
            # set the node to grey
            self.grey[node] = 1
            
            for edge in prerequisites:
                to = edge[0]
                fr = edge[1]
                if node == fr:
                    # visit the node if it is not visted
                    if self.visited[to] == 0:
                        visit(to)
                    elif self.grey[to] == 1 and self.black[to] == 0:
                        self.hascyc = True
                        return 
            
            self.black[node] = 1
            self.result = [node] + self.result
                
        for node in range(numCourses):
            if self.visited[node] == 0:
                visit(node)
                
        return self.result if not self.hascyc else []
    #+end_src
*** summary
    - detect cycles: [[Course Schedule]]
      - check if there's a *back edge*
    - can we do this in BFS ? 


** Keys and Rooms
*** problem
Input: [[1],[2],[3],[]]
Output: true
Explanation:  
We start in room 0, and pick up key 1.
We then go to room 1, and pick up key 2.
We then go to room 2, and pick up key 3.
We then go to room 3.  Since we were able to go to every room, we return true.
*** Thoughts
    - use BFS/DFS traverse graph 
    - dfs: setting black grey
    - bfs: queue, put visited node to queue 
*** code
    #+begin_src python
class Solution:
    def canVisitAllRooms(self, rooms):
        # let's do bfs this time
        self.visited = [0] * len(rooms)
        start = 0
        self.visited[start] = 1 # set visited first so that you don't have to visit it again 
        queue = []
        queue.append(start)
        while queue:            
            visit = queue.pop()      
            for neighbor in rooms[visit]:
                if self.visited[neighbor] == 0:
                    self.visited[neighbor] = 1
                    queue.append(neighbor)

        
        return all(1 == v for v in self.visited)
    #+end_src
*** summary



** Evaluate Division
*** problem
Equations are given in the format A / B = k, where A and B are variables represented as strings, and k is a real number (floating point number). Given some queries, return the answers. If the answer does not exist, return -1.0.
equations = [ ["a", "b"], ["b", "c"] ],
values = [2.0, 3.0],
queries = [ ["a", "c"], ["b", "a"], ["a", "e"], ["a", "a"], ["x", "x"] ]. 
*** Thoughts
    - typical graph probelm. 
    - DFS saving results 
*** code
    #+begin_src python
class Solution:
    def calcEquation(self, equations, values, queries):
        results = []
        def dfs(start, end, result, visited):
            # visit 
            #print(start)
            visited[start] = 1
            if start == end:
                results.append(result)
                return True
            
            for index, equ in  enumerate(equations):
                val = values[index]
                for i, edge in enumerate([equ, equ[::-1]]):
                    v = val if i == 0 else 1/val
                    s = edge[0]
                    if s == start:
                        neighbor = edge[1]
                        if neighbor not in visited:
                            if dfs(neighbor, end, result * v, visited):
                                return True
            return False
        
        temp = [e  for sub in equations for e in sub]
        for query in queries:
            visited = {}
            start = query[0]
            end = query[1]
            if start not in temp or end not in temp:
                results.append(-1)    
            elif not dfs(start, end, 1, visited):
                results.append(-1)
                
        return results
            
    #+end_src
*** summary
    - instead of using global variable to save visited, result, use function argument 
    - *use return value to trim traversal* !
    - be aware of the case that the node is not in equations at all 


** Clone Graph
*** problem
Clone an undirected graph. Each node in the graph contains a label and a list of its neighbors.
*** Thoughts
    - thinking about clone tree.
      - prenode +--> newnode
    - visited map to save the newly created node
*** code
    #+begin_src python
# Definition for a undirected graph node
# class UndirectedGraphNode:
#     def __init__(self, x):
#         self.label = x
#         self.neighbors = []

class Solution:
    def cloneGraph(self, node):        
        visited = {}        
        def dfs(node, prenode):
            # vistit the node
            if not node:
                return 
            
            #new node
            newnode = UndirectedGraphNode(node.label)
            visited[node.label] = newnode
            prenode.neighbors.append(newnode)
            
            for neighbor in node.neighbors:            
                if neighbor.label not in visited:
                    dfs(neighbor, newnode)
                else:
                    newnode.neighbors.append(visited[neighbor.label])
        
        dummy = UndirectedGraphNode(-1)
        dfs(node, dummy)
        return dummy.neighbors[0] if len(dummy.neighbors) > 0 else None
    #+end_src
*** summary
    - when visiting node, create a new node
      - this means if the node is visited, it's already existed 
    - special case { 0 -- 0,0}

** Redundant Connection                                               :ERROR:
*** problem
In this problem, a tree is an undirected graph that is connected and has no cycles.
The given input is a graph that started as a tree with N nodes (with distinct values 1, 2, ..., N), with one additional edge added. The added edge has two different vertices chosen from 1 to N, and was not an edge that already existed.
*** Thoughts
    - dfs approach is easier to think just check if it has un-connected nodes
    - don't know union find 
*** code
    #+begin_src python
# best approach: union find 
class Solution:
    def findRedundantConnection(self, edges):
        parent = [0] * (len(edges) +1)
        sizes = [1] * (len(edges) +1)
        def find(u):
            while parent[u] != u:
                u = parent[u]
            return u
        
        
        for e in edges:
            u = e[0]
            v = e[1]
            if parent[u] == 0:
                parent[u] = u
            if parent[v] == 0:
                parent[v] = v
                
            root_u = find(u)
            root_v = find(v)
            
            if root_u == root_v:
                return[u, v]
            
            # union(u, v)            
            if sizes[root_u] >= sizes[root_v]: # this is union-find optimization !
                parent[root_v] = root_u
                sizes[root_u] += sizes[root_v]                
            else:
                parent[root_u] = root_v
                sizes[root_v] += sizes[root_u]
        return None


# DFS, exceeding time
class Solution:
    def findRedundantConnection(self, edges):
        """
        :type edges: List[List[int]]
        :rtype: List[int]
        """        
        def connect(node, visited, edges):
            visited[node] = 1
            for e in edges:
                for i, edge in enumerate([e, e[::-1]]):
                    s = edge[0]
                    e = edge[1]
                    if s == node:            
                        if e not in visited:
                            connect(e, visited, edges)
                                
        
        idx = len(edges)
        for i in range(len(edges)-1, 0, -1):
            #print(edges[i])
            newedges = edges[:i] + edges[i+1:]
            visited = {}
            connect(1, visited, newedges)
            if len(visited) == len(edges):                
                return edges[i]
                

        return None
    #+end_src
*** summary
    - the problem is to find the edge whose 2 nodes are in the same union
      - single node's parent is itself 
    - union find DS/algorithm O(n)
      - find: find the root of the node
      - union: merge 2 unions beginning with 2 roots of the 2 nodes 
    - union find optimization:
      - merge to parent(node)
      - merge to the bigger union 


** Is Graph Bipartite?
*** problem
Given an undirected graph, return true if and only if it is bipartite.
*** Thoughts
    - seems tricky at first glance, but splitting =  putting nodes
      to A, B sets 
*** code
    #+begin_src python
class Solution:
    def isBipartite(self, graph):
        # bfs
        A = []
        B = []        
        def has_connect(A):
            A_connect = []
            for a in A:
                A_connect += graph[a]
            for a in A:
                if a in A_connect:
                    return True
            return False
        
        def bfs(node, visited):            
            #visit
            queue = []
            visited[node] = 1
            queue.append((node, 0))
            while queue:
                curr, depth = queue.pop()
                if depth % 2 == 0: # add to A
                    A.append(curr)        
                else: # add to B
                    B.append(curr)
                    
                for neighbor in graph[curr]:
                    if neighbor not in visited:
                        visited[neighbor] = 1
                        queue.append((neighbor, depth+1))
        
        visited = {}
        for node in range(len(graph)):
            if node not in visited:
                bfs(node, visited)
        
        if has_connect(A) or has_connect(B):
            return False
        
        return True            
    #+end_src
*** summary
    - BFS with depth. 
      - visit first, when poping up, do the operation ( simillar to 
        set it black)
        


** Reconstruct Itinerary
*** problem
Given a list of airline tickets represented by pairs of departure and arrival 
airports [from, to], reconstruct the itinerary in order. 
All of the tickets belong to a man who departs from JFK. Thus, 
the itinerary must begin with JFK.
*** Thoughts
    - dfs 
    - backtracking 
      - backtracking is what to do when reaching leaf, if you wanna go another path ignoring current node.
*** code
    #+begin_src python
class Solution(object):
    def findItinerary(self, tickets):
        visited = {}
        for ticket in tickets: # to deal with duplication 
            curr_edge = ''.join(ticket)
            visited[curr_edge] = visited.get(curr_edge, 1) - 1 # visited 0, - 1
        visited['JFK'] = 0
        
        result = []
        def dfs(node, pre):
            # visit 
            curr_edge = ''.join([pre, node])
            visited[curr_edge] += 1
            result.append(node)
            tos = []
            for ticket in tickets:
                frm = ticket[0]
                to = ticket[1]
                if frm == node:
                    tos.append(to)
            
            for to in sorted(tos):
                edge = ''.join([node, to])
                if visited[edge] <= 0:
                    if dfs(to, node):
                        return True
                    
            # to leaf. 
            if len(result) == len(tickets)+1:
                # found the result
                return True
            else:
                # back track                
                visited[curr_edge] -= 1
                result.pop(-1)
            return False
            
        dfs('JFK', '')
        return result
    #+end_src
*** summary
    - need to traverse the whole graphic at once.
      - exit coniditon: all edges visited 
    - backtrack if going to another path
    - be aware the edge could be duplicate !!!



** Minimum Height Trees                                               :ERROR:
*** problem
For a undirected graph with tree characteristics, we can choose any node as the root. The result graph is then a rooted tree. Among all possible rooted trees, those with minimum height are called minimum height trees (MHTs). Given such a graph, write a function to find all the MHTs and return a list of their root labels.
*** Thoughts
    - brute force, using bfs getting the length for each node O(n^2)
    - *3 pass*: a genius approach 
      - from anynode --> find furthest node a
      - from a ---> find furthest node b
      - finding the mid of [a, b]
    -  tree diamter is simpler thant this 
*** code
    #+begin_src c++
class Solution {
public:
    vector<int> findMinHeightTrees(int n, vector<pair<int, int>>& edges) {
        unordered_map<int, vector<int>> graph;
        for (auto e : edges) {
            graph[e.first].push_back(e.second);
            graph[e.second].push_back(e.first);
        }        
        int min_height = 1000000;
        // 3 passes
        // 1st
        vector<int> visited(n+1, 0);
        int node_a = bfs(0, visited, graph );
        std::fill(visited.begin(), visited.end(), 0);
        int node_b = bfs(node_a, visited, graph);
        std::fill(visited.begin(), visited.end(), 0);
        vector<int> result;
        vector<int> path;
        if(!dfs(node_a, node_b, visited, path, graph)) {
            return result;
        }                
        if (path.size()%2 != 0){
            int mid = path.size()/2;
            result.push_back(path[mid]);
        } else{
            int mid = path.size()/2;
            result.push_back(path[mid-1]);
            result.push_back(path[mid]);         
        }
        return result;
    }
            
    bool dfs(int node, int end, vector<int>& visited, vector<int>& path,  unordered_map<int, vector<int>>& graph) {
        visited[node] = 1;
        path.push_back(node);
        if(node == end) {
            return true;
        }        
        for (auto to : graph[node])   {    
                    if ( visited[to] == 0) { 
                        if ( dfs(to, end, visited, path, graph) ) {
                            return true;
                        }
                    }                            
        }        
        path.pop_back();
        return false;        
    }
    
    int bfs(int node, vector<int>& visited,  unordered_map<int, vector<int>>& graph) {
        int depth = -1;
        int final_node = -1;
        deque<pair<int,int>> q;
        q.push_back(pair<int, int>(node, 0));
        visited[node] = 1;
        while (!q.empty()) {
            pair<int,int> pop = q.front();            
            if (pop.second > depth) {
                depth = pop.second;
                final_node = pop.first;
            }
            
            q.pop_front();
            for (auto to : graph[pop.first])   {   
                        if ( visited[to] == 0) {
                            q.push_back(pair<int,int>(to, pop.second + 1 ));
                            visited[to] = 1;
                        }
            }            
        }
        return final_node;      
        
    }
};
    #+end_src
*** summary
    - *constructing the graph* first takes O(n), but it saves time later 
      - reduce from O(xN) -> O(n)



* BFS
** {{{color(red, Medium)}}}
** 513. Find Bottom Left Tree Value
*** problem
Given a binary tree, find the leftmost value in the last row of the tree.
*** Thoughts
    - simple BFS
    - save level info a long with the node 
*** code
    #+begin_src python
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution(object):
    def findBottomLeftValue(self, root):
        queue = []
        queue.append((root, 0 ))
        result = None
        cur_level = -1
        while queue:
            front, level = queue.pop(0)
            
            if level > cur_level:
                result = front.val
                cur_level = level
            
            if front.left:
                queue.append((front.left, level + 1))
            
            if front.right:
                queue.append((front.right, level + 1))
        
        return result 
    #+end_src
*** summary

** 515. Find Largest Value in Each Tree Row
*** problem
You need to find the largest value in each row of a binary tree.
*** Thoughts
    - BFS
    - level order traverse
*** code
    #+begin_src python
class Solution(object):
    def largestValues(self, root):
        """
        :type root: TreeNode
        :rtype: List[int]
        """
        INT_MIN = - 2 ** 32
        if not root:
            return []
        
        # traverse by row
        queue = []
        result = []
        queue.append((root, 0))
        while queue:
            last, depth  = queue.pop(0)
            if depth >= len(result):
                result.append(INT_MIN)
                
            if last.val > result[depth]:
                result[depth] = last.val
            
            if last.left:
                queue.append((last.left, depth + 1))
                
            if last.right:
                queue.append((last.right, depth + 1))
        
        return result 
        
    #+end_src
*** summary
    - saving depth info into queue 


** Surrounded Regions
*** Thoughts
    - use bfs or dfs to traverse graph 
    - flip surrounded ----> find non surrounded
      - mark all non surrounded, then you can find all surrounded
*** code
    #+begin_src python
class Solution(object):
    def solve(self, board):
        if not board:
            return 
                
        r_num = len(board)
        c_num = len(board[0])
        
        
        def avail(i, j):
            if i < 0 or i >= r_num:
                return False
            if j < 0 or j >= c_num:
                return False
            
            if board[i][j] == 'X':
                return False
            
            if board[i][j] == '+':
                return False
            
            return True
        
        
        # node = (i, j)
        def bfs(node):
            queue = []
            if avail(node[0], node[1]):
                queue.append(node)
            while queue:
                visit = queue.pop()
                v_i = visit[0]
                v_j = visit[1]
                # visited
                board[v_i][v_j] = '+'
                
                if avail(v_i + 1, v_j):
                    queue.append((v_i+1, v_j))
                if avail(v_i - 1, v_j):
                    queue.append((v_i-1, v_j))
                if avail(v_i, v_j + 1):
                    queue.append((v_i, v_j + 1))
                if avail(v_i, v_j - 1):
                    queue.append((v_i, v_j - 1))
                        
        for i in range(r_num):
            bfs((i, 0))
            bfs((i, c_num-1))

        for j in range(c_num):
            bfs((0, j))
            bfs((r_num-1, j))
            
        for i in range(r_num):
            for j in range(c_num):
                if board[i][j] == 'O':
                    board[i][j] = 'X'
                if board[i][j] == '+':
                    board[i][j] = 'O'                                     
    #+end_src
*** summary
    - 正过来想是做不出来的，要反过来想



** word ladder                                                        :ERROR:
*** Thoughts
    - bfs looking for the the word, return the depth 
      - the depth is minimal 
*** code
    #+begin_src python
class Solution(object):
    def ladderLength(self, beginWord, endWord, wordList):        
        def is_neighbor(w, word):
            count = 0
            for i in range(len(w)):
                if w[:i] + w[i+1:] == word[:i] + word[i+1:]:
                    return True   
            return False
        
        self.visited = [0] * len(wordList)
        def bfs(node):
            queue = []
            queue.append((-1, node, 0))
            
            while queue:
                index, visit, depth  = queue.pop(0)
                if visit == endWord:                    
                    return depth + 1               
                
                # visited 
                if index >= 0:
                    self.visited[index] = 1
                    
                for i, w in enumerate(wordList):
                    if self.visited[i] == 0:
                        if is_neighbor(w, visit):
                            queue.append((i,w, depth+1))
            return 0
        
        return bfs(beginWord)
    #+end_src
*** summary
    - 为什么python超时？ 是不是应该先把图construct 出来 ？ 










** 529. Minesweeper
*** problem
Input: 

[['E', 'E', 'E', 'E', 'E'],
 ['E', 'E', 'M', 'E', 'E'],
 ['E', 'E', 'E', 'E', 'E'],
 ['E', 'E', 'E', 'E', 'E']]

Click : [3,0]

Output: 

[['B', '1', 'E', '1', 'B'],
 ['B', '1', 'M', '1', 'B'],
 ['B', '1', '1', '1', 'B'],
 ['B', 'B', 'B', 'B', 'B']]
*** Thoughts
    - BFS
*** code
    #+begin_src python
class Solution(object):
    def updateBoard(self, board, click):
        R_len = len(board)
        C_len = len(board[0])
        
        if board[click[0]][click[1]] == 'M':
            board[click[0]][click[1]] = 'X'
            return board
        
        # x row, y col
        def has_mine_around(x, y):
            count = 0
            if x + 1 < R_len and y < C_len and board[x+1][y] == 'M':
                count += 1
            if x - 1 >= 0 and board[x-1][y] == 'M':
                count += 1
            if x < R_len and y + 1 < C_len and board[x][y+1] == 'M':
                count += 1
            if y - 1 >= 0 and board[x][y-1] == 'M':
                count += 1
            if x + 1 < R_len and y + 1 < C_len and board[x+1][y+1] == 'M':
                count += 1
            if x + 1 < R_len and y - 1 >= 0 and board[x+1][y-1] == 'M':
                count += 1
            if x - 1 >= 0 and y + 1 < C_len and board[x-1][y+1] == 'M':
                count += 1
            if x - 1 >= 0 and y - 1 >= 0 and board[x-1][y-1] == 'M':
                count += 1
            return count 
            
        def valid(x, y):
            if x >= 0 and x < R_len and y >= 0 and y < C_len and board[x][y] == 'E':
                return True
            return False
        
        
        def bfs(pos):
            visited = [[0 for _ in range(C_len)] for _ in range(R_len) ]
            queue = []
            visited[pos[0]][pos[1]] = 1
            queue.append(pos)
            while queue:
                x, y = queue.pop()
                
                if board[x][y] == 'M':
                    board[x][y] = 'X'
                    continue
                    
                if board[x][y] == 'B':
                    continue
                
                mine_around = has_mine_around(x, y) 
                if mine_around > 0:
                    board[x][y] = str(mine_around)
                    continue
                    
                if board[x][y] == 'E':
                    board[x][y] = 'B'
                
                
                # check the neighbors
                if valid(x+1,  y) and visited[x+1][y] == 0:
                    visited[x+1][y] = 1
                    queue.append((x+1, y))
                
                if valid(x-1, y) and visited[x-1][y] == 0:
                    visited[x-1][y] = 1
                    queue.append((x-1, y))
                
                if valid(x, y+1) and visited[x][y+1] == 0:
                    visited[x][y+1] = 1
                    queue.append((x, y+1))
                
                if valid(x, y-1) and visited[x][y-1] == 0:
                    visited[x][y-1] = 1
                    queue.append((x, y-1))
                
                if valid(x+1, y+1) and visited[x+1][y+1] == 0:
                    visited[x+1][y+1] = 1
                    queue.append((x+1, y+1))
                
                if valid(x+1, y-1) and visited[x+1][y-1] == 0:
                    visited[x+1][y-1] = 1
                    queue.append((x+1, y-1))
                
                if valid(x-1, y+1) and visited[x-1][y+1] == 0:
                    visited[x-1][y+1] = 1
                    queue.append((x-1, y+1))
                
                if valid(x-1, y-1) and visited[x-1][y-1] == 0:
                    visited[x-1][y-1] = 1
                    queue.append((x-1,y-1))
                
        bfs((click[0], click[1]))        
        return board                
    #+end_src
*** summary




* TODO DFS
** {{{color(red, Medium)}}}
** Target Sum
*** Thoughts
    - brute force recursion
    - considering using DP
      - save stete, state is 2-demension array
*** code
    #+begin_src python
class Solution(object):
    def findTargetSumWays(self, nums, S):
        def find_end_with(i, nums, s, state):
            if i == -1:
                if s == 0:
                    return 1
                else:
                    return 0     
            
            val = nums[i]
            
            if i in state and s in state[i]:
                if state[i][s] != None:
                    return state[i][s]
            
            num = ( find_end_with(i-1, nums, s+val, state) +
                  find_end_with(i-1, nums, s-val, state))   
            
            if i in state:
                state[i][s] = num
            else:
                state[i] = {}            
            return num
        
        if not nums:
            return 0
        
        state = {}        
        return find_end_with(len(nums)-1, nums, S, state)
    #+end_src
*** summary
    - so, use map to save states
    - why not using 2-d array in this case ? because S could be negative !


** perfect square
*** Thoughts
    - seeing min, considering DP 
    - state formula: f(i) = min(f(i-k) + f(k))  ----> this will be O(n^2)
      - could it be better ? f(i) = min(f(perfect_square) + 1 ) -----> O(nlogn)
*** code
    #+begin_src python
class Solution:
    def numSquares(self, n):
        if n == 0:
            return 0
        
        if n == 1:
            return 1        
        
        # f(i) = f(i-1) + f(1)
        INT_MAX = 10000000
        state = [None] * (n + 1)
        
        for i in range(n+1):                        
            perfect_square = i * i
            if perfect_square > n:
                break
                        
            state[perfect_square] = 1                
        
        state[1] = 1
        i = 2
        while i <= n:
            if state[i] != None:
                i += 1
                continue
            
            state_pre = INT_MAX
            j = 1
            while j <= i/2:
                ps = j * j
                if ps >= i:
                    break
                    
                tmp = state[i- ps] + 1
                state_pre = tmp if tmp < state_pre else state_pre
                j += 1
            
            state[i] = state_pre
            i += 1
        
        #print(state)
        return state[n]
    #+end_src
*** summary
    - DP is usually f(x) = f(y) + constant_value. 
    - DP usually better than O(n^2)




** Course Schedule
*** Thoughts
    - obviously, it's Graph problem 
*** code
    #+begin_src python
class Solution(object):
    def canFinish(self, numCourses, prerequisites):
        self.notwork = False
        self.grey = [0] * numCourses
        self.visit = [0] * numCourses
        def visit(node):
            if self.notwork:
                return              
            
            self.grey[node] = 1
            self.visit[node] = 1
                     
            for edge in prerequisites:
                s = edge[0]
                e = edge[1]
                
                if s == node:
                    if self.visit[e] == 0:
                        visit(e)
                    elif self.grey[e] == 1:
                        self.notwork = True
                        return 
                    
            self.grey[node] = 0

            
        
        for n in range(numCourses):
            # if n not visited 

            if self.visit[n] == 0:
                visit(n)
                
        return self.notwork == False
    #+end_src
*** summary


** 113. path sum ii
_*problem*_  
Given a binary tree and a sum, find all root-to-leaf paths where each path's sum equals the given sum.
_*thoughts*_  
- simple dfs saving temp states 
- note the value could be negative or positive, so 不需要剪枝
_*code*_  
#+begin_src python
class Solution(object):
    def pathSum(self, root, sum):
        result = []
        def dfs(node, left, tmp, result):
            if node == None:
                return
            
            curr_val = node.val
            if node.left == None and node.right == None:
                # leaf
                if curr_val == left:
                    result.append(tmp + [curr_val])
                return 
                                    
            dfs(node.left, left - curr_val, tmp + [curr_val], result)
            dfs(node.right, left - curr_val, tmp + [curr_val], result )
        tmp = []
        dfs(root, sum, tmp, result )
        return result 
#+end_src




* sorting & searching
** {{{color(red, Easy)}}}
** Merge Sorted Array                                              :reviewed:
   没做出来
   To save space, loop from END to START
#+begin_src python
class Solution(object):
    def merge(self, nums1, m, nums2, n):
        i = m - 1
        j = n - 1
        idx = 0
        while i >=0 and j >= 0:  # loop from end to start 
            if nums1[i] > nums2[j]:
                nums1[m + n - 1 - idx] = nums1[i]
                i = i -1
            else:
                nums1[m + n - 1 - idx] = nums2[j]
                j = j -1
            idx = idx + 1
            
        while j >= 0 :  # only check nums2, because nums1 is in-place 
            nums1[m + n - 1 - idx] = nums2[j]
            j = j - 1
            idx = idx + 1        
#+end_src

** first bad version
   typical binary searching, recursive solution 不要想太多。
#+begin_src python
class Solution(object):
    def firstBadVersion(self, n):
        self.lastBad = -1  # python closure 
        def search(i, j):
            if i > j:
                return            
            mid = (i + j)/2
            if isBadVersion(mid): # left side
                # inner functin can't change IMMUTABLE variable 
                # OR use:
                # nonlocal lastBad
                self.lastBad = mid
                search(i, mid - 1)
            else:
                search(mid + 1, j)
        
        search(1, n)
        return self.lastBad
#+end_src
** {{{color(red, Medium)}}}
** sort colors                                                        :ERROR:
    - one pass solution 做不出来 ！！
#+begin_src python
class Solution(object):
    def sortColors(self, nums):
        i0 = 0
        idx = 0
        i2 = len(nums) -1
        index = 0
        while idx <= i2:
            if nums[idx] == 0: # red
                nums[idx], nums[i0] = nums[i0], nums[idx]
                i0 += 1
                idx += 1
            elif nums[idx] == 1:
                idx += 1                
            else:
                nums[i2], nums[idx] = nums[idx], nums[i2]
                i2 -= 1
#+end_src
** top k frequent elements
   - use heap 

** find peak number
    - binary search 
    - exit condition
    - special condition first, general later 
      - 1, 2 numbers 
#+begin_src python
class Solution(object):
    def findPeakElement(self, nums):
        def find(start, end):            
            mid = (start + end) / 2
            if mid == start:
                return mid
            
            # no need to consider mid = 0 
            # because this always right nums[-1] < any number
            if nums[mid-1] < nums[mid]:
                return find(mid, end)
            else:
                return find(start, mid)
        
        return find(0, len(nums)) # ending from len(nums)
#+end_src

** sarch range                                                         :WARN:
    - always doing binary serach even after found the result 
#+begin_src python
class Solution(object):
    def searchRange(self, nums, target):
        self.sp = len(nums) # always use global to avoid closure scope problem
        self.ep = -1
        
        def find(begin, end, target):
            if begin > end:
                return
            mid = (begin + end)/2
            if nums[mid] < target: #right
                find(mid + 1, end, target)
            elif nums[mid] > target:
                find(begin, mid-1, target)
            else:
                self.sp = mid if mid < self.sp else self.sp
                self.ep = mid if mid > self.ep else self.ep
                
                # 这边想错了，想太简单了。how to find next mid ? keep using binary search !
                find(begin, mid-1, target)  # find next still using bianry search 
                find(mid+1, end, target)
                
        find(0, len(nums) - 1, target)
        if self.ep == -1:
            return [-1, -1]
        
        return [self.sp, self.ep]
#+end_src

** Search in Rotated Sorted Array                                      :WARN:
#+begin_src python
class Solution(object):
    def search(self, nums, target):
        return self.find(0, len(nums)-1, nums, target)
                
    def find(self, begin, end, nums, target):
        if begin > end:
            return -1
        
        mid = (begin + end)/2
        if nums[mid] == target:
            return mid
        
        if nums[begin] < nums[end]:
            if nums[mid] < target:
                return self.find(mid+1, end, nums, target)
            elif nums[mid] > target:
                return self.find(begin, mid-1, nums, target)
            else:
                return mid
            
        else:
            if nums[mid] >= nums[begin]:  #what if 
                # pivot on right, pivot is a GAP, not an item
                if nums[mid] > target:
                    if target > nums[begin]:
                        return self.find(begin, mid-1, nums, target)
                    elif target < nums[begin]:
                        return self.find(mid+1, end, nums, target)
                    else:
                        return begin
                elif nums[mid] < target:
                    return self.find(mid+1, end, nums, target)
                else:
                    return mid
                 
            else:
                # pivot on left
                if nums[mid] > target:
                    return self.find(begin, mid-1, nums, target)
                elif nums[mid] < target:
                    if target < nums[end]:
                        return self.find(mid+1, end, nums, target)
                    elif target > nums[end]:
                        return self.find(begin, mid-1, nums, target)
                    else:
                        return end   # confused 
                else:
                    return mid
#+end_src

** serach in 2d matrix

** H-Index
*** problem
Given an array of citations (each citation is a non-negative integer) of a researcher, write a function to compute the researcher's h-index.
*** Thoughts
    - using sorting to avoid brute force 
    - search h, h = [0, N]
*** code
    #+begin_src python
class Solution:
    def hIndex(self, citations):
        """
        :type citations: List[int]
        :rtype: int
        """
        citations = sorted(citations, reverse=True)
        h = len(citations)
        while h >= 0:
            cit = citations[h-1] if h > 0 else 1000000
            cit_right = citations[h] if h < len(citations) else -1000000
            if cit >= h and cit_right <= h:
                return h
            h -= 1
        return None        
    #+end_src
*** summary
    - looking at H-index 2. use binary search 



* backtracking
** {{{color(red, Easy)}}}
** Binary Watch
*** problem
Example:
Input: n = 1
Return: ["1:00", "2:00", "4:00", "8:00", "0:01", "0:02", "0:04", "0:08", "0:16", "0:32"]
*** Thoughts
    - getting all permutations 
*** code
    #+begin_src python
class Solution(object):
    def readBinaryWatch(self, num):
        times = [(1, 0), (2, 0), (4, 0), (8, 0), (1, 1), (2, 1), (4, 1), (8, 1), (16, 1), (32, 1)]
        
        def find(rest_times, depth):
            if depth == 0:
                return [[]]            
            result = []
            for i, time in enumerate(rest_times):
                combines = find(rest_times[i+1:], depth - 1)
                for comb in combines:
                    result.append([time] + comb)                                        
            return result
        
        final = []
        for com in find(times, num):
            hour = 0
            mins = 0
            for c in com:
                if c[1] == 0: # hour
                    hour += c[0]
                if c[1] == 1:
                    mins += c[0]
                    
            if hour >=0 and hour < 12 and mins >= 0 and mins < 60: # this is crucial 
                final.append(str(hour) + ':' + str(mins).zfill(2))
            
        return final 
    #+end_src
*** summary
    - be aware of the time condiditon
      - hour < 12, min < 60



** {{{color(red, Medium)}}}
** Letter Combinations of a Phone Number 
   - using recursion to replace N nested loops

** Generate Parentheses                                               :ERROR:
    - all combinations could be added in exit condition.
      - not always as a return 
    - () seems to be a 2 dimension problem, need to convert it to 1 dimension
      - adding (/) one by one 
    - 不要想当然，自己随便想的排列组合法肯定是错的
    - how to do this in brute force? 
      - adding )/( step by step, 
    - how to optimize brute force? only adding valid
    - recursion argeuments:
      - a starting point: could be an state, string, node etc. 
      - what is in result usually appears in the argeuments(in some form)

#+begin_src python
'''brute force generate:
(        )
((  ()   )(   ))
'''
def gen(a):
    if len(a) == 2* n:
        result.append(a) # no return recursion
        return 

    gen(a+'(')
    gen(a+')')

class Solution(object):
    def generateParenthesis(self, n):
        result = []  
        def gen(current, left, right):
            if left == n and right == n:
                result.append(current)
                return 
            
            if left < n:
                gen(current + '(', left + 1, right)
                
            if right < left:
                gen(current + ')', left, right + 1)
            
        gen('', 0, 0 )
        return result
#+end_src


** Permutations
    - just like previous problem 
#+begin_src python
class Solution(object):
    def permute(self, nums):
        if not nums:
            return []
        
        result = []
        def gen(current, left):
            if len(current) == len(nums):
                result.append(current)
                return 
            
            for i, num in enumerate(left):
                gen(current + [num], left[:i] + left[i+1:] ) 
                
        gen([], nums)
        return result                                
#+end_src


** permutations II                                                     :WARN:
*** problem
Given a collection of numbers that might contain duplicates, return all possible unique permutations.
*** Thoughts
    - easy approach
*** code
    #+begin_src c++
class Solution {
public:
    vector<vector<int>> permuteUnique(vector<int>& nums) {
        vector<vector<int>> result;
        if (nums.empty()) {
            vector<int> t;
            result.push_back(t);
            return result;
        }        
        set<vector<int>> tmp; 
        for (vector<int>::iterator it = nums.begin(); it != nums.end(); it++){
            vector<int> newnums(nums.begin(), it);
            newnums.insert(newnums.end(), it+1, nums.end());
            
            int curr = *it;
            vector<vector<int>> v = permuteUnique(newnums);
            for(int i = 0; i< v.size(); i++ ) {
                vector<int> comb = v[i];                
                vector<int> re;
                re.push_back(curr);
                re.insert(re.end(), comb.begin(), comb.end());
                tmp.insert(re);
            }
            
        }        
        std::copy(tmp.begin(), tmp.end(), std::back_inserter(result));
        return result;              
    }
};
    #+end_src
*** summary
    - shit! arr = [[]] is not vector<vector<int>> arr;
      - don't forget to initilize vector!!



** Subsets                                                             :WARN:
    - how to avoid duplicate subsets ? 
#+begin_src python
class Solution(object):
    def subsets(self, nums):
        result = []
        def gen(current, left):
            result.append(current)            
            if not left:
                return                                         
            for i, num in enumerate(left):
                gen(current + [num], left[i+1:])  # !!!        
        gen([], nums)
        return result 
#+end_src


** Subsets II
*** problem
Given a collection of integers that might contain duplicates, nums, return all possible subsets (the power set).
Note: The solution set must not contain duplicate subsets.
*** Thoughts
    - similar tot subsets I 
    - when doing dfs, keep track of visited node ( as argeument)
*** code
    #+begin_src python
class Solution(object):
    def subsetsWithDup(self, nums):
        result = {}
        def dfs(pre, left):           
            key = ''.join(sorted([str(c) for c in current]))
            result[key] = pre
            for i, num in enumerate(left):
                new_pre = [num] + pre
                new_left = left[i+1:]
                dfs(new_pre, new_left)
                
        dfs([], nums)
        return result.values()
    #+end_src
*** summary
    - be aware of passing by ref. 
      - func([num] + pre) Vs. pre += [num], func(pre), pre.pop()
    - need to sort beforing saving as key 

** word search                                                         :WARN:
    - 方法对了。但是没有最终优化
    - once found the solution, need to exit immediately !!!!
    - when doing recursion, always remmber to exit. 
      - once you found the solution, just exit.
#+begin_src python
class Solution(object):
    def exist(self, board, word):
        # self.exist_flag = False
        r_num = len(board)
        c_num = len(board[0])
        #state = [[False] * c_num for i in range(r_num)]
        def traverse(index, i, j):                        
            if i < 0 or i >= r_num or j < 0 or j >= c_num:
                return False          
            
            current = word[index]
            if board[i][j] != current:
                return False
            
            board[i][j] = '#' # reuse board so that you don't need state 
            
            # okay
            #state[i][j] = True
            if index == len(word) - 1:
                #self.exist_flag = True
                return True
            
            # how come this could save time ? once found result exit imediately
            res = (traverse(index + 1, i-1, j) or
                    traverse(index + 1, i+1, j) or
                    traverse(index + 1, i, j-1) or
                    traverse(index + 1, i, j+1) )        
            #state[i][j] = False
            board[i][j] = current
            return res
        
        if len(word) > r_num * c_num:
            return False
        
        for i in range(r_num):
            for j in range(c_num):
                if board[i][j] == word[0]:   
                    if(traverse(0, i, j)):
                        return True
        return False
        #return (self.exist_flag == True)
#+end_src

** Beautiful Arrangement
*** problem
Suppose you have N integers from 1 to N. We define a beautiful arrangement as an array that is constructed by these N numbers successfully if one of the following is true for the ith position (1 <= i <= N) in this array:
The number at the ith position is divisible by i.
i is divisible by the number at the ith position.
Now given N, how many beautiful arrangements can you construct?
*** Thoughts
    - using dfs to do permutation 
*** code
    #+begin_src python
class Solution(object):
    def countArrangement(self, N):
        """
        :type N: int
        :rtype: int
        """
        self.count = 0
        def dfs(index, nums):
            if index == N+1:
                self.count += 1
                return 
            
            for i, num in enumerate(nums):
                if num % index == 0 or index % num == 0:
                    # the number is good
                    left = nums[:i] + nums[i+1:]
                    dfs(index+1, left)

        nums = [i+1 for i in range(N)]
        dfs(1, nums)
        return self.count 
    #+end_src
*** summary
    - getting permutations is a DFS problem. 
      - use recursion


** Combinations
*** problem
Given two integers n and k, return all possible combinations of k numbers out of 1 ... n.
*** Thoughts
    - typical combination problem 
*** code
    #+begin_src python
class Solution(object):
    def combine(self, n, k):
        self.result = []
        def dfs(curr, left):
            if len(curr) == k:
                self.result.append(curr)
            
            for i, num in enumerate(left):
                new_curr = curr + [num]
                new_left = left[i+1:]
                dfs(new_curr, new_left)
                
        dfs([], [num for num in range(1,n+1)])
        return self.result        
    #+end_src
*** summary
    - this is an example how we generate combinations 
      - dfs approach ( drawing a tree structre) 
      - recursion, what does previous step look like ? (f(n) => f(n-1) ) 


** Combination Sum II
*** problem
Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.
Each number in candidates may only be used once in the combination.
*** Thoughts
    - recursion approach
    - what if candidate is 0 ? 
*** code
    #+begin_src c++
class Solution {
public:
    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {
        vector<vector<int>> result;        
        set<vector<int>> tmp;
        for(vector<int>::iterator it = candidates.begin(); it != candidates.end(); it++){
            int curr = *it;            
            if (curr > target) {
                continue;
            }
            if (curr == target) {
                vector<int> re;
                re.push_back(curr);
                tmp.insert(re);   
                continue;    
            }                        
            vector<int> left(it+1, candidates.end());                                
            for ( auto comb : combinationSum2(left, target - curr)) {
                vector<int> re;
                re.push_back(curr);
                re.insert(re.end(), comb.begin(), comb.end());
                sort(re.begin(), re.end());
                tmp.insert(re);                
            }            
            
        }        
        copy(tmp.begin(), tmp.end(), back_inserter(result));
        return result;
        
    }
};
    #+end_src
*** summary
    - curr == target is antoher stop condition
      - just like graph dfs. if curr == target, just don't go deeper. 
    - it is not always necessary to put exit condition at the beginning of function


** Combination Sum III
*** problem
Find all possible combinations of k numbers that add up to a number n, given that only numbers from 1 to 9 can be used and each combination should be a unique set of numbers.
*** Thoughts
    - permutation problem
*** code
    #+begin_src c++
class Solution {
public:
    vector<vector<int>> result;
    vector<vector<int>> combinationSum3(int k, int n) {
        vector<int> left;
        for(int i = 1; i <=9; i++){
            left.push_back(i);
        }
        vector<int> picked;
        dfs(n, left, picked, k);
        return result;
    }
    
    void dfs(int sum, vector<int>& left, vector<int>& picked, int k) {
        if (k == 0 && sum == 0) {
            result.push_back(picked);
            return;
        }
        
        if (sum <= 0) {
            return;
        }
        
        if (k <= 0) {
            return;
        }
        
        for (vector<int>::iterator it = left.begin(); it != left.end(); it++) {
            int num = *it;
            vector<int> newleft(it+1, left.end());
            vector<int> newpicked(picked);
            newpicked.push_back(num);
            dfs(sum - num, newleft, newpicked, k - 1);   
        }
        
    }
};
    #+end_src
*** summary
    - dfs needs:
      - numbers left to pick
      - numbers already picked in this run 
      - n
      - k





** Add and Search Word - Data structure design
*** problem
Design a data structure that supports the following two operations:
void addWord(word)
bool search(word)
search(word) can search a literal word or a regular expression string containing only letters a-z or .. A . means it can represent any one letter.
*** Thoughts
    - using trie.
    - since it has '.' wild match, using dfs to search
*** code
    #+begin_src python
class WordDictionary(object):    
    class Trie(object):
        def __init__(self, val):
            self.val = val
            self.children = {}
                    
    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.trie = self.Trie('root')

    def addWord(self, word):
        """
        Adds a word into the data structure.
        :type word: str
        :rtype: void
        """
        pre = self.trie
        for w in word:            
            if w not in pre.children:
                node = self.Trie(w)
                pre.children[w] = node
                pre = node 
            else:
                pre = pre.children[w]
        pre.children['#'] = None
            

    def search(self, word):
        """
        Returns if the word is in the data structure. A word could contain the dot character '.' to represent any one letter.
        :type word: str
        :rtype: bool
        """
        def dfs(node, word, depth):
            if depth == len(word):
                if '#' in node.children:                
                    return True
                else: 
                    return False
            
            w = word[depth]
            if w in node.children:
                if dfs(node.children[w], word, depth + 1):
                    return True
            elif w == '.':
                for key, child in node.children.iteritems():
                    if key != '#' and dfs(child, word, depth + 1):
                        return True
            return False
            
        
        
        node = self.trie
        return dfs(node, word, 0)
    #+end_src
*** summary
    - Trie don't forget ending. 
    - children could be 26 alphabetic character
    - Trie building: O(N), no need to use recursion
    - Trie searching: O(NM) because of '.' match. use dfs/bfs 
    - thinking about a Trie DS contians addword/findword
    - recursion in CLASS
#+begin_src python
class Trie(object):
  def add(word, index):
    node = Trie(val)
    self.children[c] = node
    self.children[c].add(word, index + 1)
#+end_src


** Gray code
*** problem
The gray code is a binary numeral system where two successive values differ in only one bit.
Given a non-negative integer n representing the total number of bits in the code, print the sequence of gray code. A gray code sequence must begin with 0.
*** Thoughts
    - dfs, change one bit each recursion
    - similar to graph visit problem
*** code
    #+begin_src python
class Solution(object):
    def grayCode(self, n):
        """
        :type n: int
        :rtype: List[int]
        """
        
        def cal(curr):
            result = 0
            for c in curr:
                result = result * 2 + c
            return result
        
        def dfs(curr, visited, result):
            # cur = [0, 0, 0]                        
            for i in reversed(range(n)):
                new_curr = list(curr)
                new_curr[i] = 1 - new_curr[i]
                key = cal(new_curr)
                if key not in visited:
                    result.append(key)
                    visited.add(key)
                    dfs(new_curr, visited, result)
                    return # don't go to other branch
                                        
        visited = set([0])
        first = [0] * n
        result = [0]
        dfs(first, visited, result)
        return result
    #+end_src
*** summary
    - it only goes to one path, so return right after recursive function finishes
      it stops the selection loop 



* Trie
** Longest Word in Dictionary                                         :ERROR:
*** problem
Given a list of strings words representing an English Dictionary, find the longest word in words that can be built one character at a time by other words in words. If there is more than one possible answer, return the longest word with the smallest lexicographical order.
If there is no answer, return the empty string.
*** Thoughts
    - Trie. when doing dfs, check if current substring in word map
*** code
    #+begin_src c++
class Solution {
    public:    
        class Trie {
        private:
            map<int, Trie*> children;
            bool isword;
        public:
            Trie() : isword(false) {
            }

            void add(const string& word){
                if (word.empty()){
                    isword = true;
                    return;
                }                
                char letter = word[0];
                int index = letter - 'a';

                if (children[index] == NULL) {
                    children[index] = new Trie();
                }                
                children[index] -> add(word.substr(1));
            }

            void dfs(const string& word, string& result, const set<string>& wordmap) {
                if (!word.empty()) {                    
                    if ( wordmap.find(word) == wordmap.end() ) {
                        return;
                    }                        
                }                
                if (isword){
                    if(word.size() > result.size()) {
                        //cout << word << endl;
                        result = word;
                    }
                }
                for (map<int, Trie*>::iterator it = children.begin(); it != children.end(); it++) {                    
                        char letter = 'a' + it->first;
                        string newword = word + letter;
                        it->second -> dfs(newword, result, wordmap);
                }
            }            
        };

        string longestWord(vector<string>& words) {
            Trie* root = new Trie();
            set<string> wordmap;
            //sort(words.begin(), words.end());
            for (auto word : words){
                wordmap.insert(word);
                root -> add(word);
            }
            string result;
            root -> dfs("", result, wordmap);
            return result; 
        }
    };

    #+end_src
*** summary
    - not familar with Trie DS. 
      - in this solution, I capsulate Trie into a class. add/find are methods of Trie
    - create a new Trie ONLY WHEN THE LETTER DOES NOT EXIST !!!

** Map Sum Pairs
*** problem
Implement a MapSum class with insert, and sum methods.
For the method insert, you'll be given a pair of (string, integer). The string represents the key and the integer represents the value. If the key already existed, then the original key-value pair will be overridden to the new one.
For the method sum, you'll be given a string representing the prefix, and you need to return the sum of all the pairs' value whose key starts with the prefix.
*** Thoughts
    - obviously it's trie 
    - when finding the prefix, traverse all nodes below it. 
*** code
    #+begin_src python
class MapSum(object):
    class Trie(object):
        def __init__(self):
            self.children = {}
            self.value = None    

    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.root = self.Trie()        

    def insert(self, key, val):
        node = self.root
        for k in key:
            if k not in node.children:
                node.children[k] = self.Trie()
            node = node.children[k]
        node.value = val        
        
    def sum(self, prefix):
        """
        :type prefix: str
        :rtype: int
        """
        def dfs(node, prefix):
            if len(prefix) == 0: # let's say if prefix is '', just traverse all nodes below                 
                if node.value: 
                    self.result += node.value
                for key in node.children:
                    dfs(node.children[key], '')                    
                return # this is exit conition, other wise out-of-range error 

            letter = prefix[0]
            left = prefix[1:]
            if letter in node.children:
                dfs(node.children[letter], left)
                
        self.result = 0
        dfs(self.root, prefix)
        return self.result
    
    #+end_src
*** summary
    - be aware of exit condition:
      - use return to prevent out-of-range error 




** Implement Magic Dictionary
*** problem
*** Thoughts
    - thinking about 'hel*o' match 
      - the difference is: * must be diffent from the original letter  
*** code
    #+begin_src python
class MagicDictionary(object):    
    class Trie(object):
        def __init__(self):
            self.children = {}
            self.iswordend = False
    

    def __init__(self):
        self.root = self.Trie()

    def buildDict(self, dict):
        for word in dict:
            # add word to root
            node = self.root
            for w in word:
                if w not in node.children:
                    node.children[w] = self.Trie()
                node = node.children[w]
            node.iswordend = True
                            
    def search(self, word):
        def dfs(node, word, changeidx):
            if not word: # empty word
                if node.iswordend:
                    return True
                return False
            
            letter = word[0]
            rest = word[1:]
            if changeidx == 0:
                for key in node.children:
                    if key != letter:
                        if dfs(node.children[key], rest, changeidx-1):
                            return True
            elif letter in node.children:
                if dfs(node.children[letter], rest, changeidx-1):
                    return True
            
            return False
            
        for i in range(len(word)):
            node = self.root
            if dfs(node, word, i):
                return True
        return False 
               
    #+end_src
*** summary
    - pass the change_index as argument. 


** Top K Frequent Words
*** problem
*** Thoughts
    - use max heap
    - or use sorting 
*** code
    #+begin_src python
class Solution(object):
    def topKFrequent(self, words, k):
        word_map = {}
        for word in words:
            word_map[word] = word_map.get(word, 0) + 1
        
        queue = []
        for key in word_map:
            heapq.heappush(queue, (word_map[key] * -1, key)) # max heap
        
        result = []
        for i in range(k):
            result.append(heapq.heappop(queue)[1])
        return result

class Solution(object):
    def topKFrequent(self, words, k):
        """
        :type words: List[str]
        :type k: int
        :rtype: List[str]
        """
        word_map = {}
        for word in words:
            word_map[word] = word_map.get(word, 0) + 1
        
        
        ret = [ key for key in sorted(word_map, key = lambda key : (-word_map[key], key)) ] 
        return ret[:k]
        
    #+end_src
*** summary

** Replace Words
*** problem
Example 1:
Input: dict = ["cat", "bat", "rat"]
sentence = "the cattle was rattled by the battery"
Output: "the cat was rat by the bat"
*** Thoughts
    - Trie
    - so the exit condition is:
      - found end node.
      - considering recursive argeument word is empty 
*** code
    #+begin_src python
class Solution(object):
    class Trie(object):
        def __init__(self):
            self.children = {}
            self.is_end = False
    
    def replaceWords(self, dict, sentence):
        def add_to_trie(word, node):
            for w in word:
                if w not in node.children:
                    node.children[w] = self.Trie()
                node = node.children[w]
            node.is_end = True
        
        def find_in_trie(word, node, path):
            if node.is_end:
                return path
            
            if not word:
                return None
            
            letter = word[0]
            rest = word[1:]
            if letter in node.children:
                ret = find_in_trie(rest, node.children[letter], path + letter)
                if ret:
                    return ret
            return None
                    
        root = self.Trie()
        for dic in dict:
            add_to_trie(dic, root)
                
        words = sentence.split()
        result = []
        for word in words:
            # replace words 
            ro= find_in_trie(word, root, '')
            if ro:
                result.append(ro)
            else:
                result.append(word)
        return ' '.join(result)
    #+end_src
*** summary
    - python class in class. don't forget self.ClassName


** Maximum XOR of Two Numbers in an Array
*** problem
Given a non-empty array of numbers, a0, a1, a2, … , an-1, where 0 ≤ ai < 231.
Find the maximum result of ai XOR aj, where 0 ≤ i, j < n.
Example:
Input: [3, 10, 5, 25, 2, 8]
Output: 28
Explanation: The maximum result is 5 ^ 25 = 28.
*** Thoughts
    - brute force is easy 
    - each bit is 0/1 thinking about Trie/tree
      - left/right node go through the trie 
      - only when left has 1 right has 0 or vise verse, the XOR is 1
      - backtracking, do not return after dfs
*** code
    #+begin_src python
class Solution(object):
    class Trie(object):
        def __init__(self):
            self.children = [None] * 2    
    
    def findMaximumXOR(self, nums):
        self.max = 0
        def bit2num(bits):
            result = 0
            for bit in bits:
                result = result * 2  + bit
            return result
        
        
        def to2bit(num):
            result  = [0] * 32
            i = 31
            while num:
                reminder = num % 2
                result[i] = reminder
                num = num / 2
                i -= 1
            return result
        
        def find_from_trie(left, right, depth, result):
            if depth == 32:
                ret = bit2num(result)
                if  ret > self.max:
                    self.max = ret
                return
            
            if (left.children[1] and right.children[0]) or (left.children[0] and right.children[1]):
                if left.children[1] and right.children[0]:
                    find_from_trie(left.children[1], right.children[0], depth + 1, result + [1]) # backtracking do not return 
                
                if left.children[0] and right.children[1]:
                    find_from_trie(left.children[0], right.children[1], depth + 1, result + [1])
                
            else:                
                if left.children[1] and right.children[1]:
                    find_from_trie(left.children[1], right.children[1], depth + 1, result + [0])
                    return
                
                if left.children[0] and right.children[0]:
                    find_from_trie(left.children[0], right.children[0], depth + 1, result + [0])
                    return
        
        
        root = self.Trie()        
        for num in nums:
            bit_array = to2bit(num)
            node = root
            for bit in bit_array:
                if node.children[bit] == None:
                    node.children[bit] = self.Trie()
                node = node.children[bit]
            
        find_from_trie(root, root, 0, [])
        return self.max
        
    #+end_src
*** summary
    - this is not a typical trie problem
      - when doing dfs, maintain 2 nodes. left, right 
    - since it's 32 bit. just create a 32 depth trie to make compare easy 


** Concatenated Words
*** problem
Given a list of words (without duplicates), please write a program that returns all concatenated words in the given list of words.
A concatenated word is defined as a string that is comprised entirely of at least two shorter words in the given array.
Example:
Input: ["cat","cats","catsdogcats","dog","dogcatsdog","hippopotamuses","rat","ratcatdogcat"]
Output: ["catsdogcats","dogcatsdog","ratcatdogcat"]
*** Thoughts
    - thinking about using Trie
    - dfs Trie, when meeting word_end, go back to root 
    - backtracking, because we don't need to always go back when meeing word_end
*** code
    #+begin_src python
class Solution(object):
    class Trie(object):
        def __init__(self):
            self.children = {}
            self.isend = False
    
    
    def findAllConcatenatedWordsInADict(self, words):
        # adding words
        def addword(node, word):
            for w in word:
                if w not in node.children:
                    node.children[w] = self.Trie()
                node = node.children[w]
            node.isend = True
                    
        def dfs(node, word, root, stage):            
            if node.isend:
                if not word:
                    if stage > 0:
                        return True
                    return False
                
            if not word:
                # serching ends
                return False
            
            letter = word[0]
            rest = word[1:]
            
            if node.isend:
                newnode = root
                if letter in newnode.children:
                    if dfs(newnode.children[letter], rest, root, stage + 1):
                        return True
                        
            if letter in node.children:
                if dfs( node.children[letter], rest, root, stage ):
                    return True
                
            return False        
        
        root = self.Trie()   
        for word in words:
            if word:
                addword(root, word)
        
        result = []
        for word in words:
            if dfs(root, word, root, 0):
                result.append(word)
        return result 
    #+end_src
*** summary
    - be aware of input "", need to filter this out !
    - Can we do this using DP ? 


* dynamic programming
  - 2 approaches: recursion and bottom up
  - key: save the states  
** {{{color(red, Easy)}}}
** Climbing Stairs
#+begin_src cpp
// classic DP
// You are climbing a stair case. It takes n steps to reach to the top.
// Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?
class Solution {
public:
    int climbStairs(int n) {
        vector<int> memo(n + 1, -1);
        return choice(n, memo);
    }
    int choice(int n , vector<int> &memo) {
        // using recursion + state dynamic approach 
        if (memo[n] != -1) {
            return memo[n];
        }
        
        if ( n ==  0 ) {
            return 0;
          }
        if ( n == 1) {
            return 1;
        }
        if ( n == 2) {
            return 2;
        }
        int result = choice(n-1, memo) + choice(n-2, memo);
        memo[n] = result;
        return result;
    }    
};
#+end_src


** max subarray 
ending with i is the key to trasfer the problem to 1 demension 
#+begin_src cpp
// Kadane algorithm
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        if (nums.size() == 0) {
            return 0;
        }
        
        vector<int> memo(nums.size(), INT_MIN);
        
        int max = INT_MIN;
        for (int i = 0; i < nums.size(); ++i) {
            int tmp = maxSumEnding(i, nums, memo) ;
            max = max > tmp ? max : tmp;
        }
        return max;
    }
    
    int maxSumEnding(int idx, const vector<int> &nums, vector<int> &memo) {
        // find the max ENDING with index i 
        // use a DP solution
        if (memo[idx] != INT_MIN) {
            return memo[idx];
        }
        
        if (idx == 0) {
            return nums[idx];
        }
        
        int tmp = maxSumEnding(idx - 1, nums, memo) + nums[idx];
        int result = nums[idx] > tmp ? nums[idx] : tmp;
        memo[idx] = result;
        return result;
    }
};
#+end_src

** house robber
得到状态方程是最重要的
#+begin_src cpp
class Solution {
public:
    int rob(vector<int>& nums) {
        vector<int> rob(nums.size(), 0); // Ending with i
        vector<int> maxR(nums.size(), 0); // max among 
        for (int i = 0 ; i < nums.size(); i++) {            
            if (i == 0) {
                rob[i] = nums[i];
                maxR[i] = nums[i];
            }
            else if (i == 1) {
                rob[i] = nums[i];
                maxR[i] =  nums[i] > nums[i-1] ? nums[i] : nums[i-1];                  
            }
            else{
                /*
                    maxR[i-2] = max ( rob[0] -> rob[i-2])
                    save the sate if you don't want to compute max again 
                */         
                rob[i] = maxR[i-2] + nums[i];
                maxR[i] =maxR[i-1] > rob[i] ? maxR[i-1] : rob[i]; // getting the correct minR

/*
or use: BETTER solution: 
                maxR[i] = max ( maxR[i-2] + nums[i] ,  maxR[i-1] )
*/
            }            
        }
        int max = 0;
        for (int i = 0; i < nums.size(); i++) {
            max = max > rob[i] ? max : rob[i];
        }
        return max;
    }
};
#+end_src
** Longest Palindromic Substring
   - For example, “aba” is a palindome, “abc” is not.
   - how to go through a matrix ? (using offset ) 
#+begin_src cpp
// this is a typical DP problem 
// still not careful enough, forgeting the exit condition
class Solution {
public:
    string longestPalindrome(string s) {
        vector<vector<bool> > P(s.size(), vector<bool>(s.size()));
        
        for (int k = 0; k < s.size(); k++){ // don't forget to exit this loop 
        for (int i = 0; i < s.size(); i++){
            if (i + k == s.size()) {
                break;
            }
            if ( k == 0) {
                P[i][i + k] = true;    
            }
            if ( k == 1) {
                P[i][i+k] = (s[i] == s[i+k]);
            }
            if ( k > 1 ){
                P[i][i+k] = P[i+1][i+k-1] && (s[i] == s[i+k]);
            }            
        }
        }
        
        int max = -1;
        string maxstring;
        for (int i = 0; i< s.size(); i ++) {
            for (int j = i; j < s.size(); j ++) {
                if (P[i][j]) {                    
                    if ( max < j - i + 1) {
                        max = j-i + 1;
                        maxstring = s.substr(i, max);
                    }
                }
            }
        }
        return maxstring;
    }
        
};

#+end_src


** longest palindome substring python
   - [None] * n only works for 1 d array 
   - python init 2-d array 不要想当然！！！
#+begin_src python
class Solution(object):
    def longestPalindrome(self, s):
        LEN = len(s)
        P = [[False] * LEN for _ in range(LEN)] #!!!!!!!!!!
            
        for offset in range(LEN):
            for i in range(LEN):
                if i + offset >= LEN:
                    break
                
                if offset == 0:
                    P[i][i] =True
                    continue
                    
                if offset == 1:
                    P[i][i+1] = (s[i] == s[i+1])
                    continue
                
                P[i][i+offset] = P[i+1][i+offset-1] and (s[i] == s[i+offset])
                
        lsub = ''
        for i in range(LEN):
            for j in range(i, LEN):
                if P[i][j]:
                    if j-i+1 > len(lsub):
                        lsub = s[i:j+1]
                    
        return lsub
                    
#+end_src
** Longest Palindromic Subsequence
*** problem
Given a string s, find the longest palindromic subsequence's length in s. You may assume that the maximum length of s is 1000.
Example 1:
Input:
"bbbab"
Output:
4
*** Thoughts
    - palindromic string: using DP
    - matrix traverse from P[i][i] -> P[i][i+k]
*** code
    #+begin_src python
class Solution(object):
    def longestPalindromeSubseq(self, s):
        if not s:
            return 0
        length = len(s)
        
        P = [[1] * length for _ in range(length)]        
        for k in range(length):
            for i in range(length-k):
                j = i + k                
                                
                if k == 0:
                    P[i][j] = 1
                    continue
                
                if k == 1:
                    P[i][j] = 2 if s[i] == s[j] else 1
                    continue                
        
                if s[i] == s[j]:
                    P[i][j] = P[i+1][j-1] + 2
                else:
                    P[i][j] = P[i+1][j] if P[i+1][j] > P[i][j-1] else P[i][j-1]
                    
        return P[0][length-1]

    #+end_src
*** summary
    - i + k < length => i < length - k, putting this into loop condition 
      - otherwise it exceeds the time 
      

** Palindromic Substrings
#+begin_src cpp
// Given a string, your task is to count how many palindromic substrings 
// in this string.
class Solution {
public:
    int countSubstrings(string s) {
        vector<vector<bool>> P(s.size(), vector<bool>(s.size(), false));
        // learn how to init a vector of vector 

        for ( int k = 0; k < s.size(); k++){
        for ( int i = 0; i < s.size(); i++) {
            if (i+k == s.size()) {
                break;
            }
            
            if (k == 0 ) {
                P[i][i+k] = true;
            } else if ( k == 1) {
                P[i][i+k] = (s[i] == s[i+k]);
            } else {
                P[i][i+k] = P[i+1][i+k-1] && (s[i] == s[i+k]);
            }            
        }
        }
        int count = 0;
        for (int i = 0; i < s.size(); i++) {
            for (int j = i; j < s.size(); j++) {
                if (P[i][j]){
                    count ++ ;
                }
            }
        }
        return count;      
    }
};


#+end_src


** Min Cost Climbing Stairs
*** problem
On a staircase, the i-th step has some non-negative cost cost[i] assigned (0 indexed).
Once you pay the cost, you can either climb one or two steps. You need to find minimum cost to reach the top of the floor, and you can either start from the step with index 0, or the step with index 1.
*** Thoughts
    - typical DP
    - state function: the min total cost ending with stair i
*** code
    #+begin_src c++
class Solution {
public:
    int minCostClimbingStairs(vector<int>& cost) {
        int len = cost.size();
        vector<int> states(len + 1);
        // f(n) = min(f(n-1), f(n-2)) + cost(n)
        if (len == 0) {
            return 0;
        }
        if (len == 1){
            return cost[0];
        }
        if (len == 2) {
            return min(cost[0], cost[1]);
        }
        
        states[0] = cost[0];
        states[1] = cost[1];
        for(int i = 2; i <= len; i++){       
            int c = 0;
            if (i != len){
                c = cost[i];
            }
            states[i] = min(states[i-1], states[i-2]) + c;
        }
        return states[len];
    }
};
    #+end_src
*** summary
    - corner case i = 0, 1
    - corner case the top floor cost[top] = 0
    - c++ duplicate declaration is wrong 


** Range Sum Query - Immutable
*** problem
Given an integer array nums, find the sum of the elements between indices i and j (i ≤ j), inclusive.
*** Thoughts
    - simple DP, finding (i, j) => sum(j) - sum(i-1)
*** code
    #+begin_src c++
class NumArray {
    vector<int> states; 
public:
    NumArray(vector<int> nums) : states(nums.size(), 0){
        if (nums.size() == 0) {
            return;
        }
        states[0] = nums[0];        
        for(int i = 1; i < nums.size(); i ++ ) {
            states[i] = states[i-1] + nums[i];
        }        
    }
    
    int sumRange(int i, int j) {
        if (states.size() == 0) {
            return 0;
        }        
        int state_i = 0;
        int state_j = states[states.size()-1];
        if (i > 0) {
            state_i = states[i-1];
        }
        if (j < states.size()) {
            state_j = states[j];
        }
        return state_j - state_i;
    }
};
    #+end_src
*** summary
     - be ware of the boundary. it's i-1, not i 



** Best Time to Buy and Sell Stock
*** problem
Say you have an array for which the ith element is the price of a given stock on day i.
If you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design an algorithm to find the maximum profit.
Note that you cannot sell a stock before you buy one.
*** Thoughts
    - saving minprice, one pass DP solution
*** code
    #+begin_src python
class Solution(object):
    def maxProfit(self, prices):
        # cash 
        profit = 0
        minprice = 2 ** 31 -1
        for i in range(len(prices)):
            price = prices[i]
            if price < minprice:
                minprice = price
            
            tmp = price - minprice
            if tmp > profit:
                profit = tmp
                
        return profit
    #+end_src
*** summary
    - similar problems:
      - [[Best Time to Buy and Sell Stock II]]
      - [[Best Time to Buy and Sell Stock III]]
      - [[Best Time to Buy and Sell Stock III]]
      - [[Best Time to Buy and Sell Stock IV]]
      - [[Best Time to Buy and Sell Stock with Cooldown]]

** Best Time to Buy and Sell Stock II
   good. use while do for loop
*** DP solution
#+begin_src python
class Solution(object):
    def maxProfit(self, prices):
        if not prices:
            return 0 
        
        P = 0
        H = - prices[0]
        for i in range(len(prices)):
            tmp = P
            P = max(P, H + prices[i])
            H = max(H, tmp - prices[i])
        return P
            
        
#+end_src
*** Greedy solution
#+begin_src python
class Solution(object):
    def maxProfit(self, prices):
        """
        :type prices: List[int]
        :rtype: int
        """
        profit = 0
        i = 0
        j = 0
        while i < len(prices): # use while do for loop 
            j = i + 1
            while j < len(prices) and prices[j] > prices[j-1]:
                j = j + 1
                
            profit = profit + prices[j-1] - prices[i]            
            i = j
            
        return profit
#+end_src



** {{{color(red, Medium)}}}
** House Robber II                                                    :ERROR:
*** problem
You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night.
*** Thoughts
    - house robber problem in a cycle 
    - just find the max for its 2 subset 
*** code
    #+begin_src python
class Solution:
    def rob(self, nums):
        def houserob(nums):
            if len(nums) == 0:
                return 0
            if len(nums) == 1:
                return nums[0]
            if len(nums) == 2:
                return nums[0] if nums[0] > nums[1] else nums[1]
            
            R = [0] * len(nums)
            R[0] = nums[0]
            R[1] = nums[0] if nums[0] > nums[1] else nums[1]
            for i in range(2, len(nums)):
                R[i] = max(R[i-2] + nums[i], R[i-1])
            
            return R[len(nums)-1]
        
        if len(nums) == 0:
            return 0
        if len(nums) == 1:
            return nums[0]
        if len(nums) == 2:
            return nums[0] if nums[0] > nums[1] else nums[1]
          
        return max(houserob(nums[:-1]), houserob(nums[1:]))                   
    #+end_src
*** summary
    - Since House[1] and House[n] are adjacent, 
    they cannot be robbed together. Therefore, the problem becomes to rob either House[1]-House[n-1] or House[2]-House[n], 

**  Jump Game                                                         :ERROR:
    - thinking about time complexity before coding 
      - if O(n^2) it is usually wrong 
      - DP is linear in this case 
#+begin_src python
class Solution(object):
    def canJump(self, nums):
        if not nums:
            return False
        
        if len(nums) == 1:
            return True
        
        # when reaching i, how many steps left ?
        P = [0] * len(nums) 
        P[0] = 0
        
        for i in range(1, len(nums)):
            P[i] = max(P[i-1], nums[i-1] ) - 1
            if P[i] < 0:
                return False
            
        return True
#+end_src

** unique path 
    - recursion is more straight forward 
    - interation needs to go through STATE table in some special sequence
#+begin_src python
class Solution:
    def uniquePaths(self, m, n):
        P = [[0] * n for _ in range(m)]
        k = 0
        while k < m and k < n:
            
            for j in range(k, n):
                if k == 0:
                    P[k][j] = 1
                else:
                    P[k][j] = P[k-1][j] + P[k][j-1]
            
            for i in range(k, m):   
                if k == 0:
                    P[i][k] = 1
                else:
                    P[i][k] = P[i-1][k] + P[i][k-1]
            
            k += 1
            
        return P[m-1][n-1]
#+end_src

** coin                                                               :ERROR:
    - 想法是对的，不过recursion 
    - bottom up approach is the best 
    - no need to use num/coin to get the val, just do P[i] = P[i-coin] + 1 

#+begin_src python
class Solution:
    def coinChange(self, coins, amount):
        INT_MAX = 2**31
        state = [[INT_MAX] * (amount+1) for _ in range(len(coins)) ]
        
        for i in range(len(coins)):
            coin = coins[i]
            for j in range(amount+1):
                if i == 0:
                    if j % coin == 0:                        
                        state[i][j] = int(j/coin)
                else:
                    if j >= coin:
                        tmp = 1 + state[i][j-coin]
                    else:
                        tmp = INT_MAX
                    state[i][j] = min(state[i-1][j], tmp)
        
        return state[len(coins)-1][amount] if state[len(coins)-1][amount] < INT_MAX else -1        
#+end_src

** Longest Increasing Subsequence                                      :WARN:
    - can you do it in nlogn ?
    - max operator not fast enough
#+begin_src python
class Solution:
    def lengthOfLIS(self, nums):
        if len(nums) == 0:
            return 0
        
        l_e = [-1] * len(nums)
        for i in range(len(nums)):
            if i == 0:
                l_e[0] = 1
                continue
                
            tmp = -1 
            for k in range(1, i+1):                   
                n = l_e[i-k] + 1 if nums[i] > nums[i-k] else 1
                tmp = tmp if tmp > n else n # do not use max operator 

            l_e[i] = tmp
            
        res = -1
        for i in range(len(nums)):
            res = max(res, l_e[i])
        return res
#+end_src


** Maximum Length of Repeated Subarray 
*** problem
Given two integer arrays A and B, return the maximum length of an subarray that appears in both arrays.
*** Thoughts
    - obviously it's a DP problem,
    - since it has 2 array A,B, thinking about using 2-D array to save the state 
*** code
    #+begin_src python
class Solution:
    def findLength(self, A, B):
        # state ending with i, j 
        f = [[0] * len(B) for _ in range(len(A))]  

        for i_a in range(len(A)):
            for i_b in range(len(B)):
                if i_a == 0 or i_b == 0:
                    if A[i_a] == B[i_b]:
                        f[i_a][i_b] = 1
                else:
                    if A[i_a] == B[i_b]:
                        f[i_a][i_b] = f[i_a-1][i_b-1] + 1
                    else:
                        f[i_a][i_b] = 0 #如果没有清楚定义状态方程，这边就会出错
        
        result = 0
        for i_a in range(len(A)):
            for i_b in range(len(B)):
                result = max(result, f[i_a][i_b])
                
        return result 
    #+end_src
*** summary
    - you should clearly define the meaning of state function
      - f(a, b) ==> the max len of substring ENDING with index a in A, index b in B
        - Ending with != previous


** Arithmetic Slices
*** problem
Example:
A = [1, 2, 3, 4]
return: 3, for 3 arithmetic slices in A: [1, 2, 3], [2, 3, 4] and [1, 2, 3, 4] itself.
*** Thoughts
    - when seeing getting the number of combination, thinking about DP
    - state function(i) = number of combination ending with i
    - use another array to save the gap 
*** code
    #+begin_src python
class Solution(object):
    def numberOfArithmeticSlices(self, A):
        states = [None] * len(A)
        nums = [0] * len(A)
        for i in range(len(A)):
            if i == 0:
                continue
            if i == 1:
                states[1] = A[1] - A[0]
                continue
                
            diff = A[i] - A[i-1]
            if states[i-1] == diff:
                nums[i] = nums[i-1] + 1
            states[i] = diff
            
        result = 0
        for num in nums:
            result += num
        return result                                 
    #+end_src
*** summary
    - typical DP with extra memonize array 


** Minimum ASCII Delete Sum for Two Strings                           :ERROR:
*** problem
Given two strings s1, s2, find the lowest ASCII sum of deleted characters to make two strings equal.
Example 1:
Input: s1 = "sea", s2 = "eat"
Output: 231
Explanation: Deleting "s" from "sea" adds the ASCII value of "s" (115) to the sum.
Deleting "t" from "eat" adds 116 to the sum.
At the end, both strings are equal, and 115 + 116 = 231 is the minimum sum possible to achieve this.
*** Thoughts
    - DP
    - since there are 2 strings, considering 2 points i, j 
      - then state function: P[i][j] is 2-d array 
*** code
    #+begin_src python
class Solution(object):
    def minimumDeleteSum(self, s1, s2):
        """
        :type s1: str
        :type s2: str
        :rtype: int
        """
        # P[i][j] = P[i+1][j+1]
        P = [ [0] * (len(s2) + 1)  for _ in range(len(s1) + 1)] 
        
        for i in range(len(s1), -1, -1): #len(s1) to 0
            for j in range(len(s2), -1, -1): # len(s2) to 0
                if i == len(s1) and j == len(s2):
                    P[i][j] = 0
                    continue
                if i == len(s1):
                    P[i][j] = P[i][j+1] + ord(s2[j])
                    continue
                if j == len(s2):
                    P[i][j] = P[i+1][j] + ord(s1[i])
                    continue
                
                if s1[i] == s2[j]:
                    P[i][j] = P[i+1][j+1]
                else:
                    P[i][j] = min(P[i][j+1] + ord(s2[j]), P[i+1][j] + ord(s1[i]))
        
        return P[0][0]                
    #+end_src
*** summary
    - i, j starts from len(s1) len(s2), instead of 0
    - state function = the minimum value when s1[i:] and s2[j:]
    - how to get state function ? 
      - when s1[i] == s2[j], ignore, no deleting. 
      - otherwise deleting i in s1 or delete j in s2
        - could draw down a binary tree to help understanding 



** Maximum Length of Pair Chain
*** problem
Example 1:
Input: [[1,2], [2,3], [3,4]]
Output: 2
Explanation: The longest chain is [1,2] -> [3,4]
*** Thoughts
    - DP
    - thinking about state less than approach not work
    - it's state ending with approach
*** code
    #+begin_src python
class Solution(object):
    def findLongestChain(self, pairs):
        f = [0] * len(pairs)
        newpairs = sorted(pairs, key=lambda v : (v[0]))
        # f(i) = f(previous(i)) + len(i)
        
        for i in range(len(newpairs)):
            p = newpairs[i]

            k = i -1
            while k >= 0 and newpairs[k][1] >= p[0]:
                k = k - 1

            fk = f[k] if k >=0 else 0
            f[i] = fk + 1

        result = 0
        for item in f:
            if item > result:
                result = item
        return result 
    #+end_src
*** summary
    - DP is not always linear time, in this case it's O(n^2)


** Best Time to Buy and Sell Stock with Transaction Fee
*** problem
Input: prices = [1, 3, 2, 8, 4, 9], fee = 2
Output: 8
Explanation: The maximum profit can be achieved by:
Buying at prices[0] = 1
Selling at prices[3] = 8
Buying at prices[4] = 4
Selling at prices[5] = 9
The total profit is ((8 - 1) - 2) + ((9 - 4) - 2) = 8.
*** Thoughts
    - thinking about brute force O(n^2). exceed time
    - when at point i, there are 2 states :
      - no stock. (cash)
        - previously no stock 
        - previously have stock, sell at i 
      - have stock (hold)
        - previous have stock, 
        - previous no stock, buy 
    - DP is essentially to traverse each options 
      - in this case, there're 3 ( states have 2 )
        - buy
        - sell
        - rest 
*** code
    #+begin_src python
class Solution(object):
    def maxProfit(self, prices, fee):
        """
        :type prices: List[int]
        :type fee: int
        :rtype: int
        """        
        cash = [0] * len(prices)  
        hold = [0] * len(prices)
        cash[0] = 0  # if can't sell 
        hold[0] = - prices[0] 
        for i in range(1, len(prices)):
            # at point i, if we no sell or sell
            cash[i] = max(cash[i-1], hold[i-1] + prices[i] - fee)
            
            # at point i we hold stock, the max profit 
            hold[i] = max(hold[i-1], cash[i-1] - prices[i])
            
        return cash[len(prices)-1]
    #+end_src
*** summary
    - link [[https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/discuss/108870/most-consistent-ways-of-dealing-with-the-series-of-stock-problems][leetcode]]




**  Best Time to Buy and Sell Stock with Cooldown
*** problem
Say you have an array for which the ith element is the price of a given stock on day i.
Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times) with the following restrictions:
You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).
After you sell your stock, you cannot buy stock on next day. (ie, cooldown 1 day)
*** Thoughts
    - similar to other buy/sell stock problem 
    - buy condition is slightly differnt 
*** code
    #+begin_src python
class Solution(object):
    def maxProfit(self, prices):
        if not prices:
            return 0
                
        S = [0] * len(prices) # no stock
        H = [0] * len(prices)
                
        for i in range(len(prices)):
            if i == 0:
                S[0] = 0
                H[0] = - prices[0]
                continue                        
            S[i] = max(S[i-1], H[i-1] + prices[i]) # sell
            
            if i == 1:
                H[1] = max(H[0], -prices[1])
                continue
            
            H[i] = max(H[i-1], S[i-2] - prices[i]) # buy
        
        return S[len(prices)-1]
    #+end_src
*** summary
    - always do defensive programming 




** Shopping Offers
*** problem
Input: [2,5], [[3,0,5],[1,2,10]], [3,2]
Output: 14
Explanation: 
There are two kinds of items, A and B. Their prices are $2 and $5 respectively. 
In special offer 1, you can pay $5 for 3A and 0B
In special offer 2, you can pay $10 for 1A and 2B. 
You need to buy 3A and 2B, so you may pay $10 for 1A and 2B (special offer #2), and $4 for 2A.
*** Thoughts
    - recursive DP ( using memonization) 
    - considering using offer is always cheaper.
      - the max for each function is: NOT using any offer !!
      - not necessarily treat price as an offer 
*** code
    #+begin_src python
class Solution(object):
    def shoppingOffers(self, price, special, needs):
        item_num = len(needs)
        def P(left, memo):
            #print left 
            key = ''.join([str(l) for l in left])
            if key in memo:
                #print '#######'
                return memo[key]
            
            if all([l == 0 for l in left]):               
                return 0
            
            if not all([l >= 0 for l in left]):
                return 100000000
                                             
            min_cost = 0 
            for i, p in enumerate(price):
                min_cost += left[i] * p
            
            for s in special:
                cost = s[-1]
                new_left = [a - b for a, b in zip(left, s[:item_num])]
                if all([ l >= 0 for l in new_left]):
                    new_min_cost = P(new_left, memo) + cost
                    min_cost = new_min_cost if new_min_cost < min_cost else min_cost
                        
            memo[key] = min_cost
            return min_cost
        
        return P(needs, {})
    #+end_src
*** summary
    - EXIT conidtion: usually equal = sth is not a correct exit condition,
      it causes infinte loop


**  Predict the Winner                                                :ERROR:
*** problem
Input: [1, 5, 2]
Output: False
Explanation: Initially, player 1 can choose between 1 and 2. 
If he chooses 2 (or 1), then player 2 can choose from 1 (or 2) and 5. If player 2 chooses 5, then player 1 will be left with 1 (or 2). 
So, final score of player 1 is 1 + 2 = 3, and player 2 is 5. 
Hence, player 1 will never be the winner and you need to return False.
*** Thoughts
    - 2 soutions:
      - naive DFS
      - minmax alogirthm + DP (cache ) 
*** code
    #+begin_src python
class Solution(object):
    def PredictTheWinner(self, nums):
        """
        :type nums: List[int]
        :rtype: bool
        """
        def minmax(i, j, cache):
            # 最大分数差是多少=当前分数减去对手分数
            if i == j:
                return nums[i]  
            
            if not cache[i][j]:
                cache[i][j] = max(nums[i] - minmax(i+1, j, cache), nums[j] - minmax(i, j-1, cache))
            
            return cache[i][j]

        cache = [[None] * len(nums) for _ in range(len(nums))]
        return minmax(0, len(nums)-1, cache) >= 0
    #+end_src
*** summary
    - AI algorithm: minmax
    - Game theory 
    - num[i] - minmax[..] ---> num[1] - (num[2] - num[3])
      - it means getting the diff of score: (num[1] + num[3]) - num[2] 
    - note How recursion works( it goes deeper until reach the end ) 



** Guess Number Higher or Lower II
*** problem
I pick a number from 1 to n. You have to guess which number I picked.
Every time you guess wrong, I'll tell you whether the number I picked is higher or lower.
However, when you guess a particular number x, and you guess wrong, you pay $x. You win the game when you guess the number I picked.
Given a particular n ≥ 1, find out how much money you need to have to guarantee a win.
*** Thoughts
    - thinking about binary search. --> WRONG
    - need to try every number in available number sets
      - for each pick, chose the max(left, right) 
      - chose the min(picks) from all possible picks 
    - adding cache. make it DP 
*** code
    #+begin_src python
class Solution(object):
    def getMoneyAmount(self, n):
        def pick(i, j, cache):
            if i >= j:
                return 0
            
            if cache[i][j]:
                return cache[i][j]
            
            result = 1000000000
            for k in range(i, j+1):
                price = k 
                result = min(result, price + max(pick(i,k-1, cache), pick(k+1, j, cache)))
                
            cache[i][j] = result 
            return result
        
        cache = [[None] * (n+1) for _ in range(n+1)]
        return pick(1, n, cache)
    #+end_src
*** summary
    - it's a minmax problem 


** 2 Keys Keyboard                                                    :ERROR:
*** problem
Initially on a notepad only one character 'A' is present. You can perform two operations on this notepad for each step:
Copy All: You can copy all the characters present on the notepad (partial copy is not allowed).
Paste: You can paste the characters which are copied last time.
Given a number n. You have to get exactly n 'A' on the notepad by performing the minimum number of steps permitted. Output the minimum number of steps to get n 'A'.
*** Thoughts
    - solution 1: naive 
    - solution 2: DP
*** code
    #+begin_src python
#DFS approach
class Solution(object):
    def minSteps(self, n):
        """
        :type n: int
        :rtype: int
        """
        self.minstep = 100000000
        def dfs(now, tmp , step):
            if now == n:
                self.minstep = min(self.minstep, step)
                return
            if now > n:
                return 
            
            if step >= self.minstep:
                return 
            if tmp > 0:
                dfs(now + tmp, tmp, step + 1)
            if tmp < now:
                dfs(now, now, step + 1)
         
        dfs(1, 0, 0)
        return self.minstep
    #+end_src

#+begin_src python
# DP approach

#+end_src

*** summary


** Delete and Earn                                                     :WARN:
*** problem
Given an array nums of integers, you can perform operations on the array.
In each operation, you pick any nums[i] and delete it to earn nums[i] points. After, you must delete every element equal to nums[i] - 1 or nums[i] + 1.
You start with 0 points. Return the maximum number of points you can earn by applying such operations.
*** Thoughts
    - using dfs will exceed the time limit
    - convert the problem to DP (house robber problem ) 
*** code
#+begin_src python
# DFS approach
class Solution(object):
    def deleteAndEarn(self, nums):
        def dfs(nums, cache):
            if not nums:
                return 0
            
            key = ''.join([str(num) for num in nums])
            
            if key in cache:
                return cache[key]
            
            maxscore = -10000000
            for i, pick in enumerate(nums):
                # removing 
                removing = (pick + 1, pick - 1)
                rest = [num for num in nums[:i] + nums[i+1:] if num != removing[0] and num != removing[1]]
        
                tmp = dfs(rest, cache) + pick
                maxscore = tmp if tmp > maxscore else maxscore
            
            cache[key] = maxscore
            
            return maxscore
        
        return dfs(sorted(nums), {})
#+end_src

    #+begin_src python
#DP approach
class Solution(object):
    def deleteAndEarn(self, nums):
        houses = [0] * 10001
        P = [0] * 10001
        for num in nums:
            houses[num] += num            
        #P(i) = P(i-1) or P(i-2) + houses[i]        
        #P[0] = 0
        #P[1] = houses[1]
        P_pre = 0
        P_curr = houses[1]
        for i in range(2, len(houses)):
            # P[i] = max(P[i-1], P[i-2] + houses[i])
            P_curr, P_pre = max(P_curr, P_pre + houses[i]), P_curr
            
        return P_curr
    #+end_src
*** summary
    - when doing DP, considering to further optimize the space 
      if state function only relates to previous state 
    - python a, b = b, a is special ( it saves the tmp state ) 




** Knight Probability in Chessboard
*** problem
On an NxN chessboard, a knight starts at the r-th row and c-th column and attempts to make exactly K moves. The rows and columns are 0 indexed, so the top-left square is (0, 0), and the bottom-right square is (N-1, N-1).
The knight continues moving until it has made exactly K moves or has moved off the chessboard. Return the probability that the knight remains on the board after it has stopped moving.
*** Thoughts
    - the probability is ( avaiable moves / total moves = 8 )
    - DP with a memonize variable 

*** code
    #+begin_src python
class Solution:
    def knightProbability(self, N, K, r, c):
        """
        :type N: int
        :type K: int
        :type r: int
        :type c: int
        :rtype: float
        """                
        # P(i,j) -> P(i-1, j-2)
        def P(i, j, k, memo):
            if i < 0 or j< 0 or i >= N or j >= N:
                return 0
            
            if k == K:
                return 1
            
            if memo[i][j][k] != -1:
                return memo[i][j][k]
            
            result = (P(i-1, j-2, k+1, memo) +
            P(i-1, j+2, k+1, memo) +
            P(i-2, j-1, k+1, memo) +
            P(i-2, j+1, k+1, memo) +
            P(i+1, j-2, k+1, memo) +
            P(i+1, j+2, k+1, memo) +
            P(i+2, j-1, k+1, memo) +
            P(i+2, j+1, k+1, memo))/float(8)
            
            memo[i][j][k] = result 
            return result 
        
        memo = []
        for i in range(N):
            memo.append([])
            for j in range(N):    
                memo[i].append([-1 for _ in range(K+1)])
                
        return P(r, c, 0, memo)        
    #+end_src
*** summary




** Triangle
*** problem
Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below.
For example, given the following triangle
[
     [2],
    [3,4],
   [6,5,7],
  [4,1,8,3]
]
The minimum path sum from top to bottom is 11 (i.e., 2 + 3 + 5 + 1 = 11).
*** Thoughts
    - basici DP, 2 approaches 
      - min_sum_ending_with(n)
      - OR min_sum_up_to(n)
*** code
    #+begin_src python
class Solution(object):
    def minimumTotal(self, triangle):
        length = len(triangle)
        if length == 0:
            return 0
        
        if length == 1:
            return triangle[0][0]
        
        P = [[10000000] * len(triangle) for _ in range(len(triangle))]
        P[0][0] = triangle[0][0]
        
        for n in range(1, len(triangle)):
            for i in range(len(triangle[n])):
                P[n][i] = min(P[n-1][i],P[n-1][i-1]) + triangle[n][i]
        
        result = 10000000
        for i in range(length):
            result = min(result, P[length-1][i])
        
        return result
    #+end_src
*** summary
    - save space ? 
      - Pn is depending on Pn-1, so it becomes P[i] = min(P[i], P[i-1])



** Combination Sum IV
*** problem
Given an integer array with all positive numbers and no duplicates, find the number of possible combinations that add up to a positive integer target.
*** Thoughts
    - recusive solution will exceed the time limit
    - when doing buttom up solution, we could write recursive solution to
      help understand 
*** code
    #+begin_src python
''' DP '''
class Solution:
    def combinationSum4(self, nums, target):        
        P = [0] * (target + 1)
        P[0] = 1
        
        for i in range(1, target + 1):
            for num in nums:
                pi_num = P[i-num] if i >= num else 0
                P[i] += pi_num
        
        
        return P[target]
        
        
        
        # P[i] = P[i-num]         
        '''
        '''
    #+end_src
#+begin_src python
''' recursion '''
    def combinationSum4(self, nums, target):        
        def P(i, memo): 
            if i == 0:
                return 1
            
            if i < 0:
                return 0
            
            if memo[i]:
                return memo[i]
                        
            result = 0
            for  num in nums:
                if i - num >= 0:
                    result += P(i-num, memo)
            
            memo[i] = result 
            return result 
        
        memo = [None] * (target + 1)
        return P(target, memo )
#+end_src
*** summary





** Largest Sum of Averages
*** problem
Example:
Input: 
A = [9,1,2,3,9]
K = 3
Output: 20
Explanation: 
The best choice is to partition A into [9], [1, 2, 3], [9]. The answer is 9 + (1 + 2 + 3) / 3 + 9 = 20.
We could have also partitioned A into [9, 1], [2], [3, 9], for example.
That partition would lead to a score of 5 + 2 + 6 = 13, which is worse.
*** Thoughts
    - use recusive solution first, then adding cache(DP)
*** code
    #+begin_src python
class Solution(object):
    def largestSumOfAverages(self, A, K):
        """
        :type A: List[int]
        :type K: int
        :rtype: float
        """
        def score(pre, depth, state):
            if state[pre][depth]:
                return state[pre][depth]
            
            
            if depth == K-1:
                tt = sum(A[pre+1:])/float(len(A)-1-pre )
                state[pre][depth] = tt
                return tt
                
            tmp = -10000000
            for i in range(pre+1, len(A)-1):
                s = sum(A[pre+1:i+1])/float(i-pre )
                tmp = max(tmp, s + score(i, depth + 1, state))
            
            state[pre][depth] = tmp
            return tmp
        
        state = [[None] * K for _ in range(len(A))]
        return score(-1, 0, state)
    #+end_src
*** summary



** Push Dominoes                                                      :ERROR:
*** problem
Example 1:
Input: ".L.R...LR..L.."
Output: "LL.RR.LLRRLL.."
Example 2:
Input: "RR.L"
Output: "RR.L"
Explanation: The first domino expends no additional force on the second domino.
*** Thoughts
    - brute force O(n) exceeding time 
    - 2 pointer, 找规律
*** code
    #+begin_src python
class Solution:
    def pushDominoes(self, dominoes):
        dom = []
        for d in dominoes:
            dom.append(d)                
        
        l = -100
        r = -100
        for i in range(len(dom)):
            if dom[i] == 'L':
                # converting dom[r:l]
                if r < 0:
                    for k in range(i):
                        dom[k] = 'L'
                else:
                    if l < r:
                        k_begin = r + 1
                        k_end = i-1
                        while k_begin  < k_end: 
                            dom[k_begin] = 'R'
                            dom[k_end] = 'L'
                            k_begin += 1
                            k_end -= 1
                    else:
                        previous_l = l
                        for k in range(previous_l, i):
                            dom[k] = 'L'
                l = i

            elif dom[i] == 'R':
                if l < r:
                    previous_r = r
                    if previous_r >= 0:
                        for k in range(previous_r, i):
                            dom[k] = 'R'
                r = i
            
        if l < r:
            for k in range(r, len(dom)):
                dom[k] = 'R'
                
        return ''.join(dom)
    #+end_src
*** summary
    - 分类讨论，write down all cases
      - XXXXX(L)
      - RXXXX(L)
      - LXXXX(L)
      - XXXXX(R)
      - LXXXX(R)
      - RXXXX(R)
      - ???(R)XXX



** Word Break
*** problem
Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, determine if s can be segmented into a space-separated sequence of one or more dictionary words.
Example 1:
Input: s = "leetcode", wordDict = ["leet", "code"]
Output: true
Explanation: Return true because "leetcode" can be segmented as "leet code".
*** Thoughts
    - DFS traversal + caching (DP) 
*** code
    #+begin_src python
class Solution(object):
    def wordBreak(self, s, wordDict):
        def dfs(word, cache):
            if not word:
                return True
            
            if word in cache:
                return cache[word]
                        
            for w in wordDict:
                w_len = len(w)
                if word.startswith(w):
                    if dfs(word[w_len:], cache):
                        return True
                    
            cache[word] = False
            return False
        
        return dfs(s, {})
    #+end_src
*** summary
    - thinking about brute force 
    - then thinking about optimize it 


** {{{color(red, Hard)}}}
** Trapping Rain Water
*** problem
Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.
The above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped. Thanks Marcos for contributing this image!
*** Thoughts
    - 如何建模？问题可以转化为： min(l_max, r_max) - current
    - once figuring out a brute force solution, thinking about DP
*** code
    #+begin_src python
class Solution(object):
    def trap(self, height):
        if len(height) < 2:
            return 0
            
        result = 0
        l_max = [0] * len(height)
        r_max = [0] * len(height)  
        
        i = 1
        l_max[0] = height[0]
        while i < len(height):
            # for each block             
            # find lelf max and right max
            new_l_max = max(l_max[i-1], height[i])
            l_max[i] = new_l_max
            i += 1
            
        i = len(height)-2
        r_max[-1] = height[-1] 
        while i >= 0:
            r_max[i] = max(r_max[i+1], height[i])
            i -= 1
            
        result = 0
        for i, h in enumerate(height):
            water = min(l_max[i],r_max[i]) - height[i]
            result += water
            
        return result             
    #+end_src
*** summary
    - O(n), O(n)
    - 难点在于如何建模。
    - stack solution
      - use a stack to store (index) 
        - push the index to stack, until finding a bigger number than top 
    - 2 pointer solution 


** Best Time to Buy and Sell Stock III
*** problem
Say you have an array for which the ith element is the price of a given stock on day i.
Design an algorithm to find the maximum profit. You may complete at most two transactions.
Note: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again).
*** Thoughts
    - DP, make number of transactions another dimension 
    - C[k][i] = at most k transactions, has only cash at point i, the max profit is. 
*** code
    #+begin_src python
class Solution(object):
    def maxProfit(self, prices):
        if not prices:
            return 0
        
        C = [[0] * len(prices) for _ in range(3)]
        H = [[0] * len(prices) for _ in range(3)]
        C[0][0] = 0
        C[1][0] = 0
        C[2][0] = 0
        H[0][0] = 0
        H[1][0] = - prices[0]
        H[2][0] = - prices[0]
        for k in range(1, 3):
            for i in range(1, len( prices)):       
                C[k][i] = max(C[k][i-1], H[k][i-1] + prices[i])
                H[k][i] = max(H[k][i-1], C[k-1][i-1] - prices[i])
                
        return C[2][len(prices) - 1]
    #+end_src
*** summary
    - # of transactions only increment when buy 




** Best Time to Buy and Sell Stock IV
*** problem
Design an algorithm to find the maximum profit. You may complete at most k transactions.
*** Thoughts
    - similar as [[Best Time to Buy and Sell Stock III]]
    - except if k is very large
*** code
    #+begin_src python
class Solution(object):
    def maxProfit(self, k, prices):
        if k == 0:
            return 0
        
        if not prices:
            return 0
        
        
        if k > len(prices)/2:
            profit = 0
            for i in range(1, len(prices)):
                diff = prices[i]-prices[i-1]
                if diff > 0:
                    profit += prices[i]-prices[i-1]
                
            return profit 
            
        
        C = [[0] * len(prices)  for _ in range(k+1)]
        H = [[0] * len(prices) for _ in range(k+1)]
        
        #H[0] = 0
        #H[1] = - prices[0]  
        for ki in range(1, k+1): 
            for i in range(0, len(prices)):  
                if i == 0:
                    H[ki][i] = -prices[0]
                    continue
                    
                C[ki][i] = max(C[ki][i-1], H[ki][i-1] + prices[i]) # sell
                H[ki][i] = max(H[ki][i-1], C[ki-1][i-1] - prices[i]) # buy
        
        return C[k][len(prices)-1]
    #+end_src
*** summary
    - could make compress the data structure. 
    - thinking about the extreme case of input. 




* divide and conquer 
** {{{color(red, Medium)}}}
** Different Ways to Add Parentheses
*** problem
Given a string of numbers and operators, return all possible results from computing all the different possible ways to group numbers and operators. The valid operators are +, - and *.
Example 1:
Input: "2-1-1"
Output: [0, 2]
Explanation: 
((2-1)-1) = 0 
(2-(1-1)) = 2
*** Thoughts
    - divide the array to left and right. then do left op right 
*** code
    #+begin_src python
class Solution(object):
    def diffWaysToCompute(self, input):
        def cal(l_n, r_n, op):
            if op == '+':
                return l_n + r_n
            if op == '-':
                return l_n - r_n
            if op == '*':
                return l_n * r_n
        
        
        def compute(nums, ops):
            #spliting to 2 parts
            if len(nums) == 0:
                raise Exception
            if len(nums) == 1:
                return [nums[0]]
            
            result = []
            for i in range(len(nums)):
                if i == len(nums) - 1:
                    continue
                l = nums[:i+1]
                r = nums[i+1:]
                op = ops[i]
                op_l = ops[:i]
                op_r = ops[i+1:]
                for l_n in compute(l,op_l):
                    for r_n in compute(r, op_r):
                        # l_n op r_n
                        res = cal(l_n, r_n, op)
                        result.append(res)
                        
            return result 
        
        ops = []
        nums = []
        curr = ''
        for i in input:
            if i == '+' or i == '-' or i == '*':
                nums.append(int(curr))
                ops.append(i)
                curr = ''
            else:
                curr += i
        nums.append(int(curr))
        return compute(nums, ops)
    #+end_src
*** summary
    - be ware of some carvets
      - compute() -> rtype: list, not a number
      - adding number to queue, not adding DIGITs


** {{{color(red, Hard)}}}
** The Skyline Problem                                                :ERROR:
*** problem
A city's skyline is the outer contour of the silhouette formed by all the buildings in that city when viewed from a distance. Now suppose you are given the locations and height of all the buildings as shown on a cityscape photo (Figure A), write a program to output the skyline formed by these buildings collectively (Figure B).
*** Thoughts
    - 扫描线问题.
      - convert the origianl data stuctre to (x, y, event)
*** code
    #+begin_src python
class Solution(object):
    def getSkyline(self, buildings):
        import heapq
        def getmax(queue):
            if not queue:
                return 0
            return 0 - queue[0] 
            #return max(queue)
                
            
        # 扫描线
        result = []
        queue = []
        # 1. convert
        lines_map = {}
        lines = []
        for b in buildings:
            x1 = b[0]
            x2 = b[1]
            y = b[2]
            lines.append((x1, y, -1))
            lines.append((x2, y, 1))
           
        # sort by 
        # 1. x1, 
        # 2. start, end 
        # 3. == start, y reverse
        # 4. == end, y
        items = sorted(lines, key = lambda k : (k[0], k[2], k[2] * k[1]))
        for item in items:
            x = item[0]
            y = item[1]
            tk = item[2]
            if tk == -1:
                queue_max = getmax(queue)
                #queue.append(y)
                heapq.heappush(queue, 0-y)
                new_queue_max = getmax(queue)
                if new_queue_max > queue_max: # change
                    result.append([x, y])   
            else:
                queue_max = getmax(queue)
                #queue.remove(y)
                
                if 0 - y == queue_max:
                    heapq.heappop(queue)
                else:
                    queue.remove(0-y)
                    heapq.heapify(queue)   
                
                new_queue_max = getmax(queue) 
                if new_queue_max != queue_max:
                    result.append([x, new_queue_max])               

        return result 
    #+end_src
*** summary
    - exceeding time limit.
      - queue's data structure: heap or bst 

    - python sorting dict. multiple criteria

* bit map 
** Single Number                                                   :reviewed:
   use bit opertion. 
   没做出来
#+begin_src python
class Solution(object):
    def singleNumber(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        x = 0
        for num in nums:
            x = x ^ num
        return x
#+end_src

** reverse Bits
   - python bit opertion 
#+begin_src python
    def reverseBits(self, n):
        sum = 0
        for i in range(32):
            remainder = n & 1 # % operatror get reminder
            sum = sum << 1 
            sum = sum ^ remainder 
            n = n >> 1
        return sum   
#+end_src


* math

** easy 
*** Fizz Buzz
    - python range(start, [stop], [step])
*** count primes                                                      :ERROR:
    - Sieve of Eratosthenes algorithm
    - prime number: 2, 3, 4 ...  1 is not prime 
 #+begin_src python
 class Solution(object):
     def countPrimes(self, n):
         if n == 0:
             return 0        
         if n == 1:
             return 0        
         if n == 2:
             return 0        
         if n == 3:
             return 1        
         state = [False] * (n)
         state[1] = False        
         for k in range(2, int(n**(0.5))+1):
             if not state[k]: 
                 #i = k
                 #j = k * i
                 j = k ** 2
                 while j < n:
                     state[j] = True
                     #i += 1
                     #j = k * i
                     j += k                    
         res = 0            
         for k in range(2, n):
             if not state[k]:
                 res += 1
            
         return res        
 #+end_src
*** hamming distance
    - use xor
    - in python3 5/2 => 2.5 (not 2), so you need to convert: int(5/2)
*** roman to integer
    - reverse array a[start, stop, steps] ====> a[-1::-1)
    - unassigned in list => END 
 #+begin_src python
 class Solution(object):
     def romanToInt(self, s):
         map = {
             'I' : 1,
             'V' : 5,
             'X' : 10,
             'L' : 50,
             'C' : 100,
             'D' : 500,
             'M' : 1000            
         }
         sum = 0
         prev = 0
         for c in s[::-1]:  # this is reverse
             current = map[c]
             if current >= prev:
                 sum += current
             else:
                 sum -= current
            
             prev = current
            
         return sum 
 #+end_src

** medium
*** Factorial Trailing Zeroes
#+begin_src python
class Solution(object):
    def trailingZeroes(self, n):
        self.total = 0
        def find5(n):
            if n == 0:
                return 
            tmp = int(n/5)
            self.total += tmp
            find5(tmp)        
        find5(n)

        return self.total
#+end_src

*** power(n,x)                                                        :ERROR:
    - binary search 
    - recursion
#+begin_src python
class Solution(object):
    def myPow(self, x, n):
        """
        :type x: float
        :type n: int
        :rtype: float
        """
        def power(x, n):
            if n == 0:
                return 1
            half = power(x, n/2)
            if n % 2 == 0:
                return half * half
            return half * half * x
        
        x = x if n >= 0 else (1/x)
        return power(x, abs(n))
               
#+end_src

*** sqrt(x)                                                           :ERROR:
    - binary serach 
    - binary serach start = mid + 1/ end = mid - 1
#+begin_src python
class Solution(object):
    def mySqrt(self, x):
        start = 0
        end = x
        if x== 0:
            return 0
        if x == 1:
            return 1
        
        while start <= end:
            mid = start + (end - start) /2 
                
            if x/mid > mid:
                start = mid + 1
            elif x/mid < mid:
                end = mid - 1
            else:
                return mid
        
        return end 
#+end_src
*** Fraction to Recurring Decimal                                      :WARN:
#+begin_src python
class Solution(object):
    def fractionToDecimal(self, numerator, denominator):
        sign = 1        
        if numerator * denominator >= 0:
            sign =1
        else:
            sign = -1

        result =""
        numerator=abs(numerator)
        denominator=abs(denominator)
        integ = int(numerator/denominator)
        if sign >= 0:
            result += str(integ)
        else:
            result += '-' + str(integ)
        
        remainder = numerator % denominator
        rmap ={}
        if remainder != 0:
            result += "."        
            remainder = remainder * 10
            # decimal 
            result1 = []
            index = 0
            while remainder != 0:
                
                if remainder in rmap:
                    result1.insert(rmap[remainder], '(')
                    result1 += [')']
                    return result + ''.join(result1)
                    
                rmap[remainder] = index
                res = int(remainder / denominator)
                remainder = remainder % denominator
                result1 += [str(res)]
                remainder = remainder * 10
                index += 1   
            return result + ''.join(result1)
        return result
#+end_src
* others
** easy
*** Pascal's Triangle
    - python reserve [[]] * n
    - another approach: Binomial coefficient
     
** medium
*** sum of 2 integers                                                 :ERROR:
    - consider negative numbers 
    - 完全不会做

*** Evaluate Reverse Polish Notation                                   :WARN:
    - use python 3 !!!! int(-1/2) = 0
    - int python 2 (-1/2) = -1

*** majority number 
    - corner case len(nums) = 1
#+begin_src python
class Solution:
    def majorityElement(self, nums):
        size = len(nums)
        num_map = {}
        for num in nums:
            if num in num_map:
                num_map[num] += 1
            else:
                num_map[num] = 1

            # check the condition after insert 
            if num_map[num] > int(size/2):
                return num
            
        return None
#+end_src

*** Task Scheduler                                                    :ERROR:
#+begin_src python
class Solution:
    def leastInterval(self, tasks, n):
        """
        :type tasks: List[str]
        :type n: int
        :rtype: int
        """
        if n == 0:
            return len(tasks)
        if not tasks:
            return 0
        
        
        task_map = {}
        result = [None] * (n+1) * len(tasks)
        index = 0
        
        task_count = {}
        for task in tasks:
            if not task in task_count:
                task_count[task] = 1
            else:
                task_count[task] += 1
                            
        count = 0        
        sum = 0
        total = None
        count = 0
        maxcount = None
        for task in sorted(task_count, key=task_count.get, reverse=True):
            if count == 0:
                maxcount = task_count[task]
                total = (task_count[task]-1) * (n + 1)
            
            if count == n+1:
                break
            
            if task_count[task] == maxcount:
                total += 1
            
            sum += task_count[task]
            count += 1
                     
        
        empty = total - sum
        left = len(tasks) - sum                
        extra = left - empty if left >= empty else 0        
        return total + extra               
#+end_src





