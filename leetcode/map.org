
#+TITLE: leetcode mind map

[[file:map_diagram.png]]

* 2 pointers
** Longest Substring Without Repeating Characters





* dynamic programming
** Climbing Stairs
#+begin_src cpp
// classic DP
// You are climbing a stair case. It takes n steps to reach to the top.
// Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?
class Solution {
public:
    int climbStairs(int n) {
        vector<int> memo(n + 1, -1);
        return choice(n, memo);
    }
    int choice(int n , vector<int> &memo) {
        // using recursion + state dynamic approach 
        if (memo[n] != -1) {
            return memo[n];
        }
        
        if ( n ==  0 ) {
            return 0;
          }
        if ( n == 1) {
            return 1;
        }
        if ( n == 2) {
            return 2;
        }
        int result = choice(n-1, memo) + choice(n-2, memo);
        memo[n] = result;
        return result;
    }    
};
#+end_src

** best time buy & sell
#+begin_src cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        if (prices.size() == 0 ) {
            // always dealt with this corner case first 
            // 不要心存侥幸 
            return 0;
        }
        
        // think about how brute force will do 
        // DP must be better than brute force 
        vector<int> profit(prices.size(), 0);        
        for (int i = 0; i < prices.size(); i++) {
            if ( i == 0 ) {
                profit[i] = 0;
            } else {
                int max = 0;
                for (int j = 0; j <= i - 1 ; j++) {
                    max = max > (prices[i] -  prices[j]) ? max : (prices[i] -  prices[j]);
                }
                
                int result = profit[i-1] > max ? profit[i-1] : max;
                profit[i] = result;                
            }            
        }
        
        return profit[prices.size() - 1];
        
    }
};
#+end_src


** Longest Palindromic Substring
For example, “aba” is a palindome, “abc” is not.
#+begin_src cpp
// this is a typical DP problem 
// still not careful enough, forgeting the exit condition
class Solution {
public:
    string longestPalindrome(string s) {
        vector<vector<bool> > P(s.size(), vector<bool>(s.size()));
        
        for (int k = 0; k < s.size(); k++){ // don't forget to exit this loop 
        for (int i = 0; i < s.size(); i++){
            if (i + k == s.size()) {
                break;
            }
            if ( k == 0) {
                P[i][i + k] = true;    
            }
            if ( k == 1) {
                P[i][i+k] = (s[i] == s[i+k]);
            }
            if ( k > 1 ){
                P[i][i+k] = P[i+1][i+k-1] && (s[i] == s[i+k]);
            }            
        }
        }
        
        int max = -1;
        string maxstring;
        for (int i = 0; i< s.size(); i ++) {
            for (int j = i; j < s.size(); j ++) {
                if (P[i][j]) {                    
                    if ( max < j - i + 1) {
                        max = j-i + 1;
                        maxstring = s.substr(i, max);
                    }
                }
            }
        }
        return maxstring;
    }
        
};

#+end_src


** Palindromic Substrings
#+begin_src cpp
// Given a string, your task is to count how many palindromic substrings 
// in this string.
class Solution {
public:
    int countSubstrings(string s) {
        vector<vector<bool>> P(s.size(), vector<bool>(s.size(), false));
        // learn how to init a vector of vector 

        for ( int k = 0; k < s.size(); k++){
        for ( int i = 0; i < s.size(); i++) {
            if (i+k == s.size()) {
                break;
            }
            
            if (k == 0 ) {
                P[i][i+k] = true;
            } else if ( k == 1) {
                P[i][i+k] = (s[i] == s[i+k]);
            } else {
                P[i][i+k] = P[i+1][i+k-1] && (s[i] == s[i+k]);
            }            
        }
        }
        int count = 0;
        for (int i = 0; i < s.size(); i++) {
            for (int j = i; j < s.size(); j++) {
                if (P[i][j]){
                    count ++ ;
                }
            }
        }
        return count;      
    }
};


#+end_src


