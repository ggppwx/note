#+TITLE: array 
* 162 peak number
A peak element is an element that is greater than its neighbors.
Given an input array where num[i] ≠ num[i+1], find a peak element and return its index.
The array may contain multiple peaks, in that case return the index to any one of the peaks is fine.
You may imagine that num[-1] = num[n] = -∞.
For example, in array [1, 2, 3, 1], 3 is a peak element and your function should return the index number 2.
click to show spoilers.
Credits:
Special thanks to @ts for adding this problem and creating all test cases.

** hint
INT_MIN vs INT_MAX



* 153 min in rotated sorted array
Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.
(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).
Find the minimum element.
You may assume no duplicate exists in the array.

** hint
always think about 'else case' when coding


* 2 sum 
Given an array of integers,
find two numbers such that they add up to a specific target number.
** hint
   - if the array is sorted, then use 2 pointer is better solution 
   - remeber this probelm is retunning indices, not the acutal number 
     
** code 
#+BEGIN_SRC python
class Solution(object):
    def twoSum(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: List[int]
        """
        map = {}
        for i, num in enumerate(nums): 
            if target - num in map:
                return [ map[target - num], i ]
            else:
                map[num] = i

        return []
#+END_SRC


* palindrome integer
palindrome integer is 121, 112211

** hint
 the key is to check if the number overflows

** code 
#+BEGIN_SRC cpp
class Solution {
public:
    bool isPalindrome(int x) {
        int sum = 0;
        int origin = x;
        while(x > 0) {     
            if (sum  > origin/10) // check if it overflows 
                return false;
            
            sum = sum * 10 + x % 10;                        
            x = x /10;             
        }
        return sum == origin;
    }
};
#+END_SRC

* implement strstr
** hint 
corner case:
"" ""
"a" "b"
** code 
#+BEGIN_SRC cpp
class Solution {
public:
    int strStr(string haystack, string needle) {
        for (int i = 0; ; i ++ ) { // no need to set the boundary 
            for (int j = 0; ; j++) {
                if (j == needle.size()){ // check it first, to avoid conner case
                    return i;
                }
                if (i+j == haystack.size()) return -1;

                if (haystack[i + j] != needle[j]){ 
                    // compare i+j, so if not work, backtrace to i 
                    break;
                }                
            }            
        }      
    }
};
#+END_SRC


* Reverse Words in a String
Given s = "the sky is blue",
return "blue is sky the".
** hint
need to reduce the space, we could retrieve the word 
** code 
#+BEGIN_SRC cpp
class Solution {
public:
    void reverseWords(string &s) {
        vector<string> words;
        string word;
        for (int i = 0; i < s.size(); i++){
            if (s[i] != ' ') {
                word += s[i];
            } else {
                if (!word.empty())
                    words.push_back(word);
                    word = ""; // reset string, don't use clear()
            }
        }
        if (!word.empty())
            words.push_back(word);
        
        s ="";
        for (int i = words.size() - 1; i> 0; i--){
            s = s +  words[i] + " ";
        }
        if (words.size() > 0) // check before accessing an array 
            s += words[0];
        
    }
};
#+END_SRC


* reverse words 2 

*  Longest Substring Without Repeating Characters
Given "abcabcbb", the answer is "abc", which the length is 3.
** hint 
   - use map to save the index
   - compare start < indexMap

** code
#+begin_src cpp
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        // sliding window, change the start point 
        // another solution is to 
        int start  = 0;
        map<char, int> charMap;
        int maxLen = 0;
        for ( int i = 0; i< s.size() ; i++) {
            if (charMap.find(s[i]) != charMap.end() && charMap[s[i]] >= start) {
                // unable to find the char 
                start =  charMap[s[i]] + 1;
            } 
            charMap[s[i]] = i;
            maxLen = maxLen > (i - start + 1) ? maxLen : (i - start + 1);
        }
        return maxLen;
    }
};
#+end_src
