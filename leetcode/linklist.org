#+TITLE: linked list

* 2 add two numbers
You are given two linked lists representing two non-negative numbers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.+
Input: (2 -> 4 -> 3) + (5 -> 6 -> 4) Output: 7 -> 0 -> 8

** hint 
- link list may have different length
- calculate 2 lists diffferently 


* 19 remove nth node
Given a linked list, remove the nth node from the end of list and return its head.+

For example,
Given linked list: 1->2->3->4->5, and n = 2.
After removing the second node from the end, the linked list becomes 1->2->3->5.

** req
- 1 time traversal

** hint 
- 2 pointers
  - 1st pointers goes to n, 2nd pointer starts. 
  - when 1st pointer finishes, 2nd pointer goes to END - n 
- starts from -1 position 

- recursion 
  - level n+1 is its parent node


* 23 merging k sorted link list
Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.+
Subscribe to see which companies asked this question

** hint 
- node starts from 0
#+begin_src
Node *result = new Node(0);
Node *tmp = result;
tmp -> next = l1;
return result->next;
#+end_src

- merge 2 link list first 
- after that merge step = step * 2 list 
- logN * k 


* swap nodes in pairs
Given a linked list, swap every two adjacent nodes and return its head.+

For example, Given 1->2->3->4, you should return the list as 2->1->4->3.
Your algorithm should use only constant space. You may not modify the values in the list, only nodes itself can be changed.

** hint
- swap node, not swap value of the node 
#+begin_src
Node *head = new Node(0);
Node *current = head;

Node *p1 = current -> next;
Node *p2 = current -> next -> next;

current = current -> next -> next;
#+end_src



* 142 link list cycle 
Given a linked list, return the node where the cycle begins. If there is no cycle, return null.
Note: Do not modify the linked list.
Follow up:
Can you solve it without using extra space?
** hint 
  - finding if it's cyclic is easy, in order to find the starting point,
    need to find the loop size
  - once found the loop size, check each node + loopsize is itself 
  - be aware of the return clause after the a code block 
  - be aware of the code block after while  
  - check if the return case covers all scenarios  


* 143 reorder link list.
Given a singly linked list L: L0?L1?…?Ln-1?Ln,
reorder it to: L0?Ln?L1?Ln-1?L2?Ln-2?…
You must do this in-place without altering the nodes' values.
For example,
Given {1,2,3,4}, reorder it to {1,4,2,3}.
** hint 
  - draw link picture to assist 
  - when writing node -> next = node2, there are usually multiple link manipulation. 
    i.e. node1->next = node->next; node -> next = node1; 
